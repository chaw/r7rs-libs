= Documentation for R7RS Libraries
Peter Lane
:doctype: book

== Introduction

The R7RS Libraries referred to here are a collection of libraries written for
or, mostly, repackaged for R7RS Scheme by Peter Lane.  The library implementations 
are available from https://github.com/petercrlane/r7rs-libs[].

The collection has been tested on Chibi, Kawa and Larceny implementations.  Any
incompatibilities or test failures are noted on the github page.  In most
cases, the collection will work on other R7RS implementations.  However, there
are some dependencies.  For example, +(slib directory)+ requires some
interaction with the operating system, which is platform specific.  Most of the
individual libraries rely on one or more SRFIs.  Those SRFIs not currently included with
Chibi or Kawa are included in the collection, as are some R6RS libraries.

See https://github.com/petercrlane/r7rs-libs/blob/master/LICENSE.md[] for license information.

include::summary.txt[]

include::subdata.txt[]

=== Getting Started

The collection can be obtained by downloading or cloning from the github link
above.  The directories are named according to each group of libraries.  Those
directories ending "-examples" or "-tests" are not needed if you are only
interested in using the libraries.

In most cases, installation is straightforward:

Download as a zip file and unpack, or clone the repository, using the 'Clone or Download'
button above: call the directory containing the files +SCHEME_LIBS+

Call your implementation with SCHEME_LIBS in its library path.  e.g.

----
    > chibi-scheme -I SCHEME_LIBS -I SCHEME_LIBS/srfis/chibi program.sps
    > larceny -path SCHEME_LIBS -r7rs -program program.sps
----

Note that Larceny has all required SRFIs to support the complete collection.
For Chibi, you also need to reference the Chibi specific SRFIs, in the
directory srfis/chibi.

.Kawa

For use in Kawa I recommend precompiling the collection into class files.  The
script +build-kawa+, for bash or msdos, compiles the complete collection and packs
it into a single jar file: +r7rs-libs.jar+

Either:

* Add this jar file to your +CLASSPATH+ for use within Kawa.
* Alternatively, for making the collection permanently available, place the .jar file in your 
  kawa/lib directory, and add the .jar file to the list in +KAWA_EXTRA_PATH+ in the relevant 
  kawa/bin script.

.Kawa note: method names with colons
****
Kawa uses the colon in symbol names specially to refer to Java method calls.
When you want to mix Java calls with libraries containing names with colons,
you should rename on import or use the | ... | vertical bar syntax when
referring to the library names.
****

=== Documentation

Most of this document describes the libraries under the +robin+ subcollection.  These 
libraries cover a range of functionality, including a logger, statistics library, 
an implementation of Lisp's Series package, and a range of functions for working with 
text.  Each library is covered in a separate chapter.

The final chapter introduces the bulk of this collection, which are the
collections of libraries repackaged or ported from other sources.  These
collections often have their own documentation available elsewhere, so links
are provided.

.Help Wanted
****
Many of the ported libraries have inadequate documentation / examples, making them hard 
to pick up and get started with.  Send me examples to include in the repository.  Write 
documentation on your web pages or blogs, or send to include here.  
****

== Abbrev: +(import (robin abbrev))+

indexterm:[abbrev]
Create unique abbreviations for a list of strings.  This library is a port of the equivalent Ruby library.

=== abbrev

Input:

* a list of strings
* an optional prefix

Output:

* an association list mapping unique abbreviations to its matching string

For example:

----
#|kawa:9|# (import (robin abbrev))
#|kawa:10|# (abbrev '("scheme" "scala" "lisp"))
((lisp . lisp) (lis . lisp) (li . lisp) (l . lisp) 
 (scala . scala) (scal . scala) (sca . scala) 
 (scheme . scheme) (schem . scheme) (sche . scheme) (sch . scheme))
----

The first line shows that any prefix to "lisp" is an acceptable, unique
abbreviation: because no other word in the list of strings starts with the
letter "l".  For Scala and Scheme, the unique abbreviations start with three
letters, as "s" and "sc" are prefixes to both.

The optional prefix will only include words that have that prefix, allowing us to select a subset of the strings to generate abbreviations for.  For example:

----
#|kawa:11|# (abbrev '("scheme" "scala" "lisp") "s")
((scala . scala) (scal . scala) (sca . scala) 
 (scheme . scheme) (schem . scheme) (sche . scheme) (sch . scheme))
----

With the "s" prefix included, "lisp" is no longer in the output.

== Constants: +(import (robin constants))+

indexterm:[constants]
This library was born out of frustration in not having PI to hand when needed.  It provides 
some mathematical or physical constants for use in calculations. (You probably want to use +only+ or 
+prefix+ statements when using this library, as some of the constants are single letters.)

.Currently provided constants
[width="50%",cols="5,1",frame="all",options="header"]
|============================================
|Description                      |Name
|Newton's constant of gravitation | indexterm2:[G]
|Speed of light in a vacuum       | indexterm2:[c]
|PI                               | indexterm2:[PI]
|e                                | indexterm2:[e]
|============================================

Use very simply:

----
#|kawa:1|# (import (robin constants))
#|kawa:2|# PI
3.141592653589793
#|kawa:3|# G
6.67408E-11
#|kawa:4|# (define (area r) (* PI r r))
#|kawa:5|# (area 3)
28.274333882308138
----

== Directory: +(import (robin directory))+

indexterm:[directory]
This library is implementation specific, providing a common interface for working with directories.
Some of the details of the output will vary depending on implementation (e.g. whether directories 
are included when listing files).

The library only supports Chibi, Kawa and Larceny at present.

=== current-directory

indexterm2:[+current-directory+] returns the current working directory (as a string):

----
#|kawa:1|# (import (robin directory))
#|kawa:2|# (current-directory)
/home/peter/Software/r7rs-libs/robin
----

=== list-directory-files

indexterm2:[+list-directory-files+] returns a list of the _filenames_ in the given directory:

----
#|kawa:4|# (list-directory-files (current-directory))
(srfi64-utils.sld logger.sld series.sld abbrev.sld
 disjoint-set.sld text.sld directory.sld statistics.sld
 constants.sld)
#|kawa:5|# (list-directory-files "../robin-tests")
(statistics-test.sps text-test.sps logger-test.sps voc.txt series-test.sps
 abbrev-test.sps output.txt)
----

=== list-directory-paths

indexterm2:[+list-directory-paths+] returns a list of the _pathnames_ of files in the given directory:

----
#|kawa:15|# (list-directory-paths (current-directory))
(/home/peter/Software/r7rs-libs/robin/srfi64-utils.sld
 /home/peter/Software/r7rs-libs/robin/logger.sld
 /home/peter/Software/r7rs-libs/robin/series.sld
 /home/peter/Software/r7rs-libs/robin/abbrev.sld
 /home/peter/Software/r7rs-libs/robin/disjoint-set.sld
 /home/peter/Software/r7rs-libs/robin/text.sld
 /home/peter/Software/r7rs-libs/robin/directory.sld
 /home/peter/Software/r7rs-libs/robin/statistics.sld
 /home/peter/Software/r7rs-libs/robin/constants.sld)
----

=== make-directory

indexterm2:[+make-directory+] creates a directory with the given name:

----
#|kawa:16|# (make-directory "test-directory")
----


== Disjoint Set: +(import (robin disjoin-set))+

indexterm:[disjoint set]
A disjoint-set data structure holds items in distinct sets (or groups).  Efficient procedures are 
provided for finding a representative of the set any item is contained in, and also for 
joining two sets together.

=== make-disjoint-set
          
indexterm2:[+make-disjoint-set+] takes two parameters: the equality function to use on 
terms, and a hash function (e.g. SRFI 69's +hash+, +string-hash+ or +hash-by-identity+).
The return value is a disjoint set.

=== disjoint-set?

indexterm2:[+disjoint-set?+] 
checks if its argument is a disjoint-set instance or not, returning a boolean value.

=== disjoint-set:make 

indexterm2:[+disjoint-set:make+] places an item into the disjoint-set as its own group.
Takes two arguments: the disjoint set and the item.  Return value is undefined.

=== disjoint-set:find 

indexterm2:[+disjoint-set:find+] takes two arguments, the disjoint set and an item.  The 
function returns the representative item for the group that the given item is in.

=== disjoint-set:union

indexterm2:[+disjoint-set:union+] takes three arguments, the disjoint set and two items.  The 
disjoint set is modified to combine the groups that the two items are in.

=== disjoint-set:size

indexterm2:[+disjoint-set:size+] takes a disjoint set and returns the number of
distinct groups it contains.

=== Example: Kruskal's Algorithm

indexterm:[Kruskal's Algorithm]
This example illustrates how disjoint sets can be used in Kruskal's algorithm to find a 
minimal spanning set.  (The complete code is in "robin-examples/kruskal.sps")

[source,lisp]
----
(define (kruskal graph)
  (let ((result '())
        (nodes (delete-duplicates (append (map car graph) (map cadr graph)) eq?)))
    ; 1. make a disjoint set, with each node an item
    (let ((ds (make-disjoint-set eq? hash-by-identity)))        ; <1>
      (for-each (lambda (node) (disjoint-set:make ds node))     ; <2>
                nodes)
      ; 2. set 'links' holds all the links in graph, sorted with the shortest first
      (let loop ((links (sort graph (lambda (a b) (< (caddr a) (caddr b))))))
        ; 3. if links non-empty and size > 1
        (when (and (not (null? links))
                   (> (disjoint-set:size ds) 1))                ; <3>
          (let ((link (car links)))
            (unless (eq? (disjoint-set:find ds (car link))      ; <4>
                         (disjoint-set:find ds (cadr link)))
              (set! result (cons link result))
              (disjoint-set:union ds (car link) (cadr link))))  ; <5>
          (loop (cdr links)))))
    (reverse result)))

;; using it
(let* ((graph '((a b 3) (a e 1) (b c 5) (b e 4) (c d 2) (c e 6) (d e 7)))
       (res (kruskal graph)))
  (format #t "MST has ~a links~&" (length res))
  (format #t "~{   : ~a~&~}" res)                               ; <6>         
  (format #t "Total length: ~a~&" (fold + 0 (map caddr res))))
----
<1> Creates a disjoint set using +eq?+ for equality and +hash-by-identity+ for the hash function, 
    because individual items are symbols.
<2> Each node is added to the disjoint set, initially in its own group.
<3> The number of groups in the disjoint set tells us how many links remain to be added.
<4> Look for a link where its end points are in different groups: tested by finding the representative 
    item of each end point's group in the disjoint set.
<5> When we add a link, connect the groups in the disjoint set.
<6> Note use of +format+ to print a list of items

Output:
----
MST has 4 links
   : (a e 1)
   : (c d 2)
   : (a b 3)
   : (b c 5)
Total length: 11
----

== Logger: +(import (robin logger))+

indexterm:[logger]  The Logger library is used to output messages to an output
port.  Each message is given a level, and only messages above a certain set
level will be output to the port.  This allows the developer to control the
level of detail output by the program.  This logger library uses the same
levels as Ruby's Logger class: 

. unknown: An unknown message that should always be logged.
. fatal: An unhandleable error that results in a program crash.
. error: A handleable error condition.
. warn: A warning.
. info: Generic (useful) information about system operation.
. debug: Low-level information for developers.

=== new-logger

indexterm2:[+new-logger+] creates a new logger object.  It accepts one argument: if the argument 
is a port, the logged output will be directed at that port; if the argument is a string, then the 
string will be treated as a filename, and the logger will open the file and send output to it.

Use +(current-input-port)+ to set the logger to output to the terminal. 

=== logger?

indexterm2:[+logger?+] checks if the given object is a logger object or not.

=== log-close

indexterm2:[+log-close+] used to close up the logger.  This only has an effect if the logger was 
created with a string, and has opened its own output file: the file port created by the logger is 
then closed.  

=== log-add

indexterm2:[+log-add+] is used to output a message.  It accepts three arguments:

* +logger+ is the log object to use for the output
* +msg+ is the message to output, and must be a string
* +level+ is the log level to use for the output

Usually you will use one of the functions described in the next subsection, but sometimes it is useful for 
the program to decide which log level to output a message at.

=== log-unknown log-fatal log-error log-warn log-info log-debug

indexterm2:[+log-unknown+] 
indexterm2:[+log-fatal+] 
indexterm2:[+log-error+] 
indexterm2:[+log-warn+] 
indexterm2:[+log-info+] 
indexterm2:[+log-debug+] all accept two arguments, the log object and a message to output.  The message is 
output if the log level mentioned in the function name is a valid one given the log object's current log level.

=== log-level

indexterm2:[+log-level+] accepts two arguments, a log object and a log level, and sets the logger's level. 

=== log-unknown? log-fatal? log-error? log-warn? log-info? log-debug?

indexterm2:[+log-unknown?+]
indexterm2:[+log-fatal?+] 
indexterm2:[+log-error?+] 
indexterm2:[+log-warn?+] 
indexterm2:[+log-info?+] 
indexterm2:[+log-debug?+] all accept one argument, the log object, and return true if a log message at the given 
level would be output by the log object.

=== Example

The following example illustrates how these functions may be used:

[source,lisp]
----
(define log (new-logger "log1.txt"))      ; <1>
(log-level log 'info)                     ; <2>
(log-info log "some information logged")  ; <3>
(log-debug log "this will be ignored")    ; <4>
(log-level log 'debug)                    ; <5>
(log-debug log "but this included")       ; <6>
(log-close log)                           ; <7>
----
<1> Create a new logger, output to the given file
<2> Sets the log level to "info"
<3> Outputs a line at "info" level, which will be output
<4> Tries to output a line at "debug" level, but this will be ignored as it is lower than the set level
<5> Sets the log level to "debug"
<6> And now the log message at "debug" level will be output
<7> Finally, close the logger, which closes the file port it opened

The output from the above example is sent to the file "log1.txt", which contains two lines.  Notice the log level 
precedes each message.

----
$ more log1.txt 
info: some information logged
debug: but this included
----

== Series: +(import (robin series))+

indexterm:[series]
An implementation of Richard Waters' Lisp Series package.

.Note
****
This package is still experimental.  In particular, it is not optimised.
****

=== Scanners

Scanners create series.

==== series

indexterm2:[series]

==== series?

indexterm2:[series?]

==== make-series

indexterm2:[make-series]

==== scan

indexterm2:[scan]

==== scan-list

indexterm2:[scan-list]

==== scan-vector

indexterm2:[scan-vector]

==== scan-string

indexterm2:[scan-string]

==== scan-range

indexterm2:[scan-range]

==== scan-sublists

indexterm2:[scan-sublists]

==== scan-alist

indexterm2:[scan-alist]

==== scan-file

indexterm2:[scan-file]

==== scan-fn

indexterm2:[scan-fn]

==== scan-fn-inclusive

indexterm2:[scan-fn-inclusive]

=== Mapping

==== map-fn

indexterm2:[map-fn]

=== Truncation

==== until

indexterm2:[until]

==== until-if

indexterm2:[until-if]

=== Other On-Line Transducers

==== previous

indexterm2:[previous]

=== Choosing and Expanding

==== choose

indexterm2:[choose]

==== choose-if

indexterm2:[choose-if]

==== spread

indexterm2:[spread]

==== expand

indexterm2:[expand]

=== Other Off-Line Transducers

==== catenate

indexterm2:[catenate]

==== subseries

indexterm2:[subseries]

==== positions

indexterm2:[positions]

==== mask

indexterm2:[mask]

==== mingle

indexterm2:[mingle]

=== Collectors

==== collect-last

indexterm2:[collect-last]

==== collect-first

indexterm2:[collect-first]

==== collect-nth

indexterm2:[collect-nth]

==== collect

indexterm2:[collect]

==== collect-string

indexterm2:[collect-string]

==== collect-append

indexterm2:[collect-append]

==== collect-alist

indexterm2:[collect-alist]

==== collect-file

indexterm2:[collect-file]

==== collect-length

indexterm2:[collect-length]

==== collect-sum

indexterm2:[collect-sum]

==== collect-max

indexterm2:[collect-max]

==== collect-min

indexterm2:[collect-min]

==== collect-and

indexterm2:[collect-and]

==== collect-or

indexterm2:[collect-or]

==== collect-fn

indexterm2:[collect-fn]


== SRFI 64 Utilities: +(import (robin srfi64-utils))+

Some convenience functions for unit testing with SRFI 64.

=== test-approx-same

indexterm2:[+test-approx-same+] checks if two inexact numbers are within a given bound.  This is 
the same as +test-approximate+ except that the tolerance is optional, and defaults to 0.001.

----
#|kawa:32|# (test-approx-same 1 1.001)
#|kawa:33|# (test-approx-same 1 1.001 0.0001)
robin/srfi64-utils.sld:65: FAIL
----

=== test-compare

indexterm2:[+test-compare+] checks if two given items satisfy the given comparison procedure.

This is useful for testing equality of more complex data.  For example, we might want to check if 
just the first item of sublists are the same:

----
#|kawa:34|# (import (srfi 1))
#|kawa:41|# (define (equal-cars? i1 i2) (every (lambda (l1 l2) (equal? (car l1) (car l2))) i1 i2))
#|kawa:42|# (test-compare equal-cars? '((1 2) (3 4)) '((1 5) (3 6)))
#|kawa:43|# (test-compare equal-cars? '((1 2) (3 4)) '((1 5) (4 6)))
robin/srfi64-utils.sld:69: FAIL
----

=== test-no-error

indexterm2:[+test-no-error+] is used to confirm that a piece of code has _not_ thrown an error.
In the following example, the first line raises an +error+, and so the test fails.
The second line does not raise an +error+, and so the test passes.

----
#|kawa:27|# (test-no-error (if (zero? 0) (error "") #t))
robin/srfi64-utils.sld:55: FAIL
#|kawa:28|# (test-no-error (if (zero? 1) (error "") #t))
#|kawa:29|# 
----

== Statistics: +(import (robin statistics))+

indexterm:[statistics]  A library of functions to compute statistical or 
other information about sets of data.

=== mean

Computes the arithmetic indexterm2:[+mean+] of a list of numbers.  
This is the familiar "add up all the numbers, divide by the total" average.

----
#|kawa:2|# (mean '(1 2 3 4 5))
3
----

=== arithmetic-mean

indexterm:[arithmetic-mean] Same as +mean+.

=== geometric-mean

indexterm:[+geometric-mean+]  The geometric mean takes the nth root of the 
product of the numbers, where +n+ is the size of the data.  This yields the 
central number within a geometric progression.

----
#|kawa:3|# (geometric-mean '(1 2 3 4 5))
2.605171084697352
#|kawa:4|# (geometric-mean '(1 3 9 27 81))
9.000000000000002
#|kawa:5|# (geometric-mean '(1 3 9 27))
5.196152422706632
----

=== harmonic-mean

indexterm:[+harmonic-mean+]  The harmonic mean is the reciprocal of the arithmetic 
mean of the reciprocals.

----
#|kawa:6|# (harmonic-mean '(1 2 3 4 5))
300/137
#|kawa:7|# (inexact (harmonic-mean '(1 2 3 4 5)))
2.18978102189781
----

=== median

The indexterm2:[+median+] is the central number, when all the numbers are put in order 
(or, when there are an even number of numbers, the average of the two middle numbers).

----
#|kawa:8|# (median '(5 3 1 2 4))
3
----

=== mode

The indexterm2:[+mode+] is the number appearing most often.  The +mode+ function returns 
two values: a list of the most frequent number or numbers, and their number of occurrences.

----
#|kawa:9|# (mode '(5 3 1 2 4))
(1 2 3 4 5) 1
#|kawa:11|# (let-values (((items count) (mode '(5 3 5 1 2 4))))
#|.....12|# (display items) (newline) (display count) (newline))
(5)
2
----

=== percentile

indexterm2:[+percentile+] takes two arguments, a list of data and a +percent+
value, and returns the item in the list at that percentile position along the
list, or an average of the nearest two values.  +percent+ values must be in the
range 1 to 99, inclusive.  Note that a +percent+ of 50 corresponds to the
+median+.

----
#|kawa:13|# (percentile '(1 2 3 4 5) 50)
3
#|kawa:14|# (percentile '(1 2 3 4 5) 75)
4
#|kawa:16|# (percentile '(1 2 3 4 5) 99)
5
#|kawa:19|# (percentile '(1 2 3 4 5) 85)
5
#|kawa:20|# (percentile '(1 2 3 4 5) 80)
9/2
----

=== population-standard-deviation

indexterm2:[+population-standard-deviation+] of a list of data:

----
#|kawa:28|# (population-standard-deviation '(1 2 3 4 5))
1.4142135623730951
----

Optionally, if you know the mean of your data, pass that as a second argument so the 
function does not have to recompute it:

----
#|kawa:39|# (population-standard-deviation '(1 2 3 4 5) 3)
1.4142135623730951
----

=== population-variance

indexterm2:[+population-variance+] of a list of data:

----
#|kawa:29|# (population-variance '(1 2 3 4 5))
2
----

Optionally, if you know the mean of your data, pass that as a second argument so the 
function does not have to recompute it.

=== standard-deviation

indexterm2:[+standard-deviation+] of a list of data:

----
#|kawa:30|# (standard-deviation '(1 2 3 4 5))
1.5811388300841898
----

Optionally, if you know the mean of your data, pass that as a second argument so the 
function does not have to recompute it.

=== variance

indexterm2:[+variance+] of a list of data:

----
#|kawa:31|# (variance '(1 2 3 4 5))
5/2
----

Optionally, if you know the mean of your data, pass that as a second argument so the 
function does not have to recompute it.

=== coefficient-of-variation

indexterm2:[+coefficient-of-variation+] describes the amount of spread in a dataset relative to its mean.
In the following example, both lists have the same mean (3), but the spread is greater in the second.

----
#|kawa:32|# (coefficient-of-variation '(1 2 3 4 5))
52.70462766947299
#|kawa:33|# (coefficient-of-variation '(-2 2 3 4 8))
120.18504251546631
----

=== standard-error-of-the-mean

indexterm2:[+standard-error-of-the-mean+] describes the mean of the sampling distribution.

----
#|kawa:35|# (standard-error-of-the-mean '(1 2 3 4 5))
0.7071067811865476
----

=== sign

indexterm2:[+sign+] returns 1 for positive numbers, 0 for zero, -1 for negative numbers

----
#|kawa:36|# (sign 10)
1
#|kawa:37|# (sign 0)
0
#|kawa:38|# (sign -0.7)
-1
----

=== jaccard-index

The indexterm2:[+jaccard-index+] returns a number from 0 to 1 indicating how _similar_
two sets are.  Sets here are represented as lists, and duplicates are ignored.  An optional 
third argument provides the set-equality function (which defaults to +equal?+).

----
#|kawa:40|# (jaccard-index '(1 2 3 4 5) '(3 4 5 6 7))
3/7
#|kawa:42|# (jaccard-index '(1 2 3 4 5) '(3 4 5 1 2 2 1 1))
1
#|kawa:43|# (jaccard-index '("a" "b" "c") '("A" "B" "F"))
0
#|kawa:45|# (jaccard-index '("a" "b" "c") '("A" "B" "D") string-ci=?)
1/2
----

.Note
****
Interestingly, the Jaccard Index is a distance _metric_ satisfying, in particular, the triangle 
inequality.
****

=== jaccard-distance

The indexterm2:[+jaccard-distance+] is simply +(1 - (jaccard-index))+, and measures how _dissimilar_ 
the two sets are.

----
#|kawa:46|# (jaccard-distance '(1 2 3 4 5) '(3 4 5 6 7))
4/7
----

=== sorenson-dice-index

The indexterm2:[+sorenson-dice-index+] is a measure of the similarity of two
sets.  Sets here are represented as lists, and duplicates are ignored.  An
optional third argument provides the set-equality function (which defaults to
+equal?+).

----
#|kawa:47|# (sorenson-dice-index '(1 2 3 4 5) '(3 4 5 6 7))
3/5
#|kawa:48|# (sorenson-dice-index '("a" "b" "c") '("A" "B" "D"))
0
#|kawa:49|# (sorenson-dice-index '("a" "b" "c") '("A" "B" "D") string-ci=?)
2/3
----


== Text: +(import (robin text))+

indexterm:[text] The text library contains a collection of functions for working with strings or 
text documents.

=== porter-stem

indexterm2:[+porter-stem+] is an implementation of the well-known Porter Stemming Algorithm, for 
reducing words to a base form.  More details of the algorithm are at https://tartarus.org/martin/PorterStemmer/[]

The function simply takes the word to change, and returns the stemmed form:

----
> (porter-stem "running")
"run"
> (porter-stem "apples")
"appl"
> (porter-stem "apple")
"appl"
> (porter-stem "approximation")
"approxim"
> (porter-stem "sympathize")
"sympath"
> (porter-stem "sympathise") 
"sympathis"
----

=== sorenson-dice-similarity

indexterm2:[+sorenson-dice-similarity+] returns a measure of how similar two strings are, based 
on bigrams of characters:

----
> (sorenson-dice-similarity "rabbit" "racket")
1/5
> (sorenson-dice-similarity "sympathize" "sympthise")
10/17
----

=== soundex

indexterm2:[+soundex+] is simply reexported from +(slib soundex)+.  The implementation is 
from Knuth, Vol. 3 "Sorting and searching", pp.391-2.

The soundex algorithm returns a code for a word, and equivalent sounding words should return 
equivalent codes:

----
> (soundex "pair")
"P600"
> (soundex "pare")
"P600"
> (soundex "rabbit")
"R130"
> (soundex "racket")
"R230"
> (soundex "smith")
"S530"
> (soundex "smythe")
"S530"
----

=== string->n-grams

indexterm2:[+string->n-grams+] separates a string into overlapping groups of +n+ letters.

----
> (string->n-grams "ABCDE" 1)
("A" "B" "C" "D" "E")
> (string->n-grams "ABCDE" 3)
("ABC" "BCD" "CDE")
----

For +n+ greater than the length of the string, the string itself is returned.
If +n+ is less than 1, an error is raised.

=== words->with-commas

indexterm2:[+words->with-commas+] is a function taking a list of strings and 
adding commas in between the items up to the last item, which is preceded 
by an "and".  For example:

[source,lisp]
----
> (words->with-commas '())
""
> (words->with-commas '("apple"))
"apple"
> (words->with-commas '("apple" "banana"))
"apple and banana"
> (words->with-commas '("apple" "banana" "chikoo"))
"apple, banana and chikoo"
> (words->with-commas '("apple" "banana" "chikoo" "damson"))
"apple, banana, chikoo and damson"
> (words->with-commas '("apple" "banana" "chikoo" "damson") #t)
"apple, banana, chikoo, and damson"
----

An optional second argument controls whether the final "and" should be 
preceded by a comma.  The default is not to have the comma.

=== word-wrap

indexterm2:[+word-wrap+] takes two arguments, a string and a target width.
It returns the string formatted so words do not go beyond the target width.
The algorithm is a simple greedy algorithm.  If words are too long for the target 
width, they are allowed to overlap.

For example, setting:

----
(define *text* "Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary. Scheme demonstrates that a very small number of rules for forming expressions, with no restrictions on how they are composed, suffice to form a practical and efficient programming language that is flexible enough to support most of the major programming paradigms in use today.")
----

We can wrap to a width of 50 characters using:

----
> (word-wrap *text* 50)
Programming languages should be designed not by
piling feature on top of feature, but by removing
the weaknesses and restrictions that make
additional features appear necessary. Scheme
demonstrates that a very small number of rules for
forming expressions, with no restrictions on how
they are composed, suffice to form a practical and
efficient programming language that is flexible
enough to support most of the major programming
paradigms in use today.
----

and we can wrap to a width of 60 characters using:

----
> (word-wrap *text* 60)
Programming languages should be designed not by piling
feature on top of feature, but by removing the weaknesses
and restrictions that make additional features appear
necessary. Scheme demonstrates that a very small number of
rules for forming expressions, with no restrictions on how
they are composed, suffice to form a practical and efficient
programming language that is flexible enough to support most
of the major programming paradigms in use today.
----

== Repackaged or Ported Libraries

Most of the libraries available in this collection have been repackaged or
ported from earlier versions of Scheme, or Lisp, to work under R7RS Scheme
implementations.  Modifications have been kept to a minimum to make the code
work.  Test scripts and examples are available for some parts of these
libraries and may be examined for ideas on how each library works. 

=== Natural Language Tool Kit: +(import (nltk NNNN))+

indexterm:[nltk]
A repackaging of libraries from the Natural Language ToolKit: https://sourceforge.net/projects/snltk/[]

*    dfsa
*    lang-en
*    lang-hr
*    n-grams
*    sequence
*    vectorspace

(Not the +cgi+ package, as the necessary support libraries are not present.)

These libraries support natural-language processing tasks, such as dividing text into n-grams, analysing or 
displaying the n-grams, and working with a deterministic finite-state automaton.

Some tests and examples are provided, but otherwise this collection needs documenting.

=== Purely Functional Data Structures: +(import (pfds NNNN))+

indexterm:[pfds]
A repackaging of _Purely Functional Data Structures_, originally written for R6RS Scheme: https://github.com/ijp/pfds[]

These data structures implement algorithms from a variety of sources (see the README at above link).

*    bounded-balance-tree
*    deque
*    difference-list
*    fingertree
*    hash-array-mapped-trie
*    heap
*    priority-search-queue
*    queue
*    sequence
*    set

And, to support implementation:

*    alist
*    bitwise
*    lazy-list
*    list-helpers
*    vector

Some tests and examples are provided, but otherwise this collection needs documenting.

=== R6RS: +(import (r6rs NNNN))+

indexterm:[r6rs]
As many of the libraries have been ported from R6RS implementations, they depend on some 
R6RS functionalities - particularly fixnum arithmetic and bytevectors.  Some of these 
have been taken from http://snow-fort.org[] in support of the repackaging (particularly for Weinholt).

=== Rebottled

indexterm:[rebottled]
Some libraries ported from older Scheme versions or Common Lisp: these libraries are individual 
or very few files.

==== CL-PDF: +(import (rebottled cl-pdf))+

indexterm:[cl-pdf]
Originally written for Common Lisp by Marc Battyani, this library was then ported to Scheme 
by Bruce Butterfield.

The library allows us to construct and output PDF documents.  The following example 
displays two repeated blocks of text and a title in a variety of fonts, sizes and 
positions in the document.

[source,lisp]
----
(define (ex1)
  (pdf:with-document-to-file 
    "ex1.pdf"
    (let ((helvetica (pdf:build-font "Helvetica"))
          (courier (pdf:build-font "Courier")))
      (pdf:with-page
        (pdf:in-text-mode
          (pdf:set-font (pdf:font-name helvetica) 36)
          (pdf:move-text 100 750)
          (pdf:draw-text "scm-pdf: Example 1"))
        (pdf:in-text-mode
          (dotimes (i 25)
            (pdf:set-font (pdf:font-name helvetica) (* i 1.5))
            (pdf:move-text (+ i 5) (+ i 10))
            (pdf:draw-text "Helvetica")))
        (pdf:in-text-mode
          (dotimes (i 25)
            (pdf:set-font (pdf:font-name courier) (* i 1.5))
            (pdf:move-text (+ i 5) (- 50 (+ i 10)))
            (pdf:draw-text "Courier")))))))
----            

This library needs documentation, and some helper functions to layout larger blocks of text.

==== Portable Regular Expressions: +(import (rebottled pregexp))+

indexterm:[pregexp]
Written by Dorai Sitaram, this library is documented at:
http://ds26gte.github.io/pregexp/index.html[]

==== Quaternions: +(import (rebottled quaternions))+

indexterm:[quaternions]
Written by Dorai Sitaram, this library is documented at:
http://www.ccs.neu.edu/home/dorai/squat/squat.html[]

The quaternions library extends the Scheme numeric tower.  

==== Schelog: +(import (rebottled schelog))+

indexterm:[schelog]
Written by Dorai Sitaram, this library is documented at:
https://ds26gte.github.io/schelog/index.html[]

=== SLIB: +(import (slib NNNN))+

indexterm:[slib]
SLIB is a collection of packages of Scheme code, mostly written by Aubrey
Jaffer, but some collected from other sources.  Looking through the files, some
of the original dates go back to 1991, and the precedence parser into 1989.  A
number of ideas now found in Scheme and captured in the SRFIs can be traced
back to SLIB.  The repackaged files in +r7rs-libs+ have been adapted to work
with R7RS Scheme implementations: using R7RS functionality, the library system,
and operations now found in SRFIs.  

There are 91 libraries within the R7RS SLIB collection.  These fall within four main 
groups of functionality:

. Textual Conversion Packages, including a parser, I/O routines, html and xml processing, 
  pretty-printing of Scheme objects, and procedures to handle times and dates.
. Mathematical Libraries, including prime numbers, some random number distributions, plotting 
  functions (to text and eps), root/limit finding libraries and a 3D modelling suite.
. Database Packages, which implement a relational database system, and a library for weighted
  trees.
. Other Packages
.. Data Structures: for enhancing arrays, working with pnm files, an object system and queues.
.. Sorting and Searching: trees, chapter-order, topological sort, along with some space filling 
   curves and sequence comparisons.
.. Other Procedures: a library of metric units for computing conversions.

See documentation at http://people.csail.mit.edu/jaffer/slib[], but SLIB could do with 
further examples and third-party descriptions.

The github page for +r7rs-libs+ and the wiki, https://github.com/petercrlane/r7rs-libs/wiki[],
provide additional information about SLIB and its conversion for use as R7RS libraries.  

The "examples" and "tests" directories provide (some) examples of using SLIB.


=== SRFI: +(import (srfi NN))+

indexterm:[srfi] The +r7rs-libs+ include some SRFIs for Chibi and Kawa.  These
are provided solely to provide support for the above libraries.  Although
mostly complete in themselves, SRFI-64, for example, only provides those
functions needed in the test suites to support Chibi, wrapping 
equivalent +(chibi test)+ functions.

For documentation on the SRFIs, see http://srfi.schemers.org/final-srfis.html[]

=== Weinholt Industria: +(import (weinholt NNNN))+

indexterm:[weinholt]
This collection is still in process of being repackaged.  It contains a collection of algorithms for 
working with compression algorithms, performing cryptography, and interacting with networks.  

Documentation is available at: https://weinholt.se/industria/manual/[]

See https://github.com/petercrlane/r7rs-libs[] for information on which libraries are currently available.

[appendix]
== Information on Required Imports

The following tables show, for each library, the non-R7RS imports which it
requires, and also the libraries that it is imported into.  So no libraries
such as +(scheme base)+ are shown.  The intention is to assist in deciding
which parts of the collection are required to support specific functionality,
making it easier to distribute only the libraries required for an application.
e.g. +(robin statistics)+ relies on SRFIs 1, 69 and 95. 

(WARNING: The lists do not currently list libraries imported using
+cond-expand+ statements.  For example +(robin text)+ requires SRFI 13 or
equivalent functions from other libraries.)

include::alldata.txt[]


[index]
== Index

