= Documentation for R7RS Libraries
Peter Lane
:doctype: book

== Introduction

The R7RS Libraries referred to here are a collection of libraries written for
or, mostly, repackaged for R7RS Scheme by Peter Lane.  The library implementations 
are available from https://github.com/petercrlane/r7rs-libs[].

The collection has been tested on Chibi, Kawa and Larceny implementations.  Any
incompatibilities or test failures are noted on the github page.  In most
cases, the collection will work on other R7RS implementations.  However, there
are some dependencies.  For example, +(slib directory)+ requires some
interaction with the operating system, which is platform specific.  Most of the
individual libraries rely on one or more SRFIs.  Those SRFIs not currently included with
Chibi or Kawa are included in the collection, as are some R6RS libraries.

See https://github.com/petercrlane/r7rs-libs/blob/master/LICENSE.md[] for license information.

=== Getting Started

The collection can be obtained by downloading or cloning from the github link
above.  The directories are named according to each group of libraries.  Those
directories ending "-examples" or "-tests" are not needed if you are only
interested in using the libraries.

In most cases, installation is straightforward:

Download as a zip file and unpack, or clone the repository, using the 'Clone or Download'
button above: call the directory containing the files +SCHEME_LIBS+

Call your implementation with SCHEME_LIBS in its library path.  e.g.

----
    > chibi-scheme -I SCHEME_LIBS -I SCHEME_LIBS/srfis/chibi program.sps
    > larceny -path SCHEME_LIBS -r7rs -program program.sps
----

Note that Larceny has all required SRFIs to support the complete collection.
For Chibi, you also need to reference the Chibi specific SRFIs, in the
directory srfis/chibi.

.Kawa

For use in Kawa I recommend precompiling the collection into class files.  The
script +build-kawa+, for bash or msdos, compiles the complete collection and packs
it into a single jar file: +r7rs-libs.jar+

Either:

* Add this jar file to your +CLASSPATH+ for use within Kawa.
* Alternatively, for making the collection permanently available, place the .jar file in your 
  kawa/lib directory, and add the .jar file to the list in +KAWA_EXTRA_PATH+ in the relevant 
  kawa/bin script.

.Kawa note: method names with colons
****
Kawa uses the colon in symbol names specially to refer to Java method calls.
When you want to mix Java calls with libraries containing names with colons,
you should rename on import or use the | ... | vertical bar syntax when
referring to the library names.
****

=== Libraries

Most of this document describes the libraries under the +robin+ subcollection.  These 
libraries cover a range of functionality, including a logger, statistics library, 
an implementation of Lisp's Series package, and a range of functions for working with 
text.  Each library is covered in a separate chapter.

The final chapter introduces the bulk of this collection, which are the
collections of libraries repackaged or ported from other sources.  These
collections often have their own documentation available elsewhere, so links
are provided.

.Help Wanted
****
Many of the ported libraries have inadequate documentation / examples, making them hard 
to pick up and get started with.  Send me examples to include in the repository.  Write 
documentation on your web pages or blogs, or send to include here.  
****

== Abbrev: +(import (robin abbrev))+

indexterm:[abbrev]
Create unique abbreviations for a list of strings.  This library is a port of the equivalent Ruby library.

=== abbrev

Input:

* a list of strings
* an optional prefix

Output:

* an association list mapping unique abbreviations to its matching string

For example:

----
#|kawa:9|# (import (robin abbrev))
#|kawa:10|# (abbrev '("scheme" "scala" "lisp"))
((lisp . lisp) (lis . lisp) (li . lisp) (l . lisp) 
 (scala . scala) (scal . scala) (sca . scala) 
 (scheme . scheme) (schem . scheme) (sche . scheme) (sch . scheme))
----

The first line shows that any prefix to "lisp" is an acceptable, unique
abbreviation: because no other word in the list of strings starts with the
letter "l".  For Scala and Scheme, the unique abbreviations start with three
letters, as "s" and "sc" are prefixes to both.

The optional prefix will only include words that have that prefix, allowing us to select a subset of the strings to generate abbreviations for.  For example:

----
#|kawa:11|# (abbrev '("scheme" "scala" "lisp") "s")
((scala . scala) (scal . scala) (sca . scala) 
 (scheme . scheme) (schem . scheme) (sche . scheme) (sch . scheme))
----

With the "s" prefix included, "lisp" is no longer in the output.

== Constants: +(import (robin constants))+

indexterm:[constants]
This library was born out of frustration in not having PI to hand when needed.  It provides 
some mathematical or physical constants for use in calculations. (You probably want to use +only+ or 
+prefix+ statements when using this library, as some of the constants are single letters.)

.Currently provided constants
[width="50%",cols="5,1",frame="all",options="header"]
|============================================
|Description                      |Name
|Newton's constant of gravitation | indexterm2:[G]
|Speed of light in a vacuum       | indexterm2:[c]
|PI                               | indexterm2:[PI]
|e                                | indexterm2:[e]
|============================================

Use very simply:

----
#|kawa:1|# (import (robin constants))
#|kawa:2|# PI
3.141592653589793
#|kawa:3|# G
6.67408E-11
#|kawa:4|# (define (area r) (* PI r r))
#|kawa:5|# (area 3)
28.274333882308138
----

== Directory: +(import (robin directory))+

indexterm:[directory]
This library is implementation specific, providing a common interface for working with directories.
Some of the details of the output will vary depending on implementation (e.g. whether directories 
are included when listing files).

The library only supports Chibi, Kawa and Larceny at present.

=== current-directory

indexterm2:[+current-directory+] returns the current working directory (as a string):

----
#|kawa:1|# (import (robin directory))
#|kawa:2|# (current-directory)
/home/peter/Software/r7rs-libs/robin
----

=== list-directory-files

indexterm2:[+list-directory-files+] returns a list of the _filenames_ in the given directory:

----
#|kawa:4|# (list-directory-files (current-directory))
(srfi64-utils.sld logger.sld series.sld abbrev.sld
 disjoint-set.sld text.sld directory.sld statistics.sld
 constants.sld)
#|kawa:5|# (list-directory-files "../robin-tests")
(statistics-test.sps text-test.sps logger-test.sps voc.txt series-test.sps
 abbrev-test.sps output.txt)
----

=== list-directory-paths

indexterm2:[+list-directory-paths+] returns a list of the _pathnames_ of files in the given directory:

----
#|kawa:15|# (list-directory-paths (current-directory))
(/home/peter/Software/r7rs-libs/robin/srfi64-utils.sld
 /home/peter/Software/r7rs-libs/robin/logger.sld
 /home/peter/Software/r7rs-libs/robin/series.sld
 /home/peter/Software/r7rs-libs/robin/abbrev.sld
 /home/peter/Software/r7rs-libs/robin/disjoint-set.sld
 /home/peter/Software/r7rs-libs/robin/text.sld
 /home/peter/Software/r7rs-libs/robin/directory.sld
 /home/peter/Software/r7rs-libs/robin/statistics.sld
 /home/peter/Software/r7rs-libs/robin/constants.sld)
----

=== make-directory

indexterm2:[+make-directory+] creates a directory with the given name:

----
#|kawa:16|# (make-directory "test-directory")
----


== Disjoint Set: +(import (robin disjoin-set))+

indexterm:[disjoint set]


== Logger: +(import (robin logger))+

indexterm:[logger]  The Logger library is used to output messages to an output
port.  Each message is given a level, and only messages above a certain set
level will be output to the port.  This allows the developer to control the
level of detail output by the program.  This logger library uses the same
levels as Ruby's Logger class: 

. unknown: An unknown message that should always be logged.
. fatal: An unhandleable error that results in a program crash.
. error: A handleable error condition.
. warn: A warning.
. info: Generic (useful) information about system operation.
. debug: Low-level information for developers.

=== new-logger

indexterm2:[+new-logger+] creates a new logger object.  It accepts one argument: if the argument 
is a port, the logged output will be directed at that port; if the argument is a string, then the 
string will be treated as a filename, and the logger will open the file and send output to it.

Use +(current-input-port)+ to set the logger to output to the terminal. 

=== logger?

indexterm2:[+logger?+] checks if the given object is a logger object or not.

=== log-close

indexterm2:[+log-close+] used to close up the logger.  This only has an effect if the logger was 
created with a string, and has opened its own output file: the file port created by the logger is 
then closed.  

=== log-add

indexterm2:[+log-add+] is used to output a message.  It accepts three arguments:

* +logger+ is the log object to use for the output
* +msg+ is the message to output, and must be a string
* +level+ is the log level to use for the output

Usually you will use one of the functions described in the next subsection, but sometimes it is useful for 
the program to decide which log level to output a message at.

=== log-unknown log-fatal log-error log-warn log-info log-debug

indexterm2:[+log-unknown+] 
indexterm2:[+log-fatal+] 
indexterm2:[+log-error+] 
indexterm2:[+log-warn+] 
indexterm2:[+log-info+] 
indexterm2:[+log-debug+] all accept two arguments, the log object and a message to output.  The message is 
output if the log level mentioned in the function name is a valid one given the log object's current log level.

=== log-level

indexterm2:[+log-level+] accepts two arguments, a log object and a log level, and sets the logger's level. 

=== log-unknown? log-fatal? log-error? log-warn? log-info? log-debug?

indexterm2:[+log-unknown?+]
indexterm2:[+log-fatal?+] 
indexterm2:[+log-error?+] 
indexterm2:[+log-warn?+] 
indexterm2:[+log-info?+] 
indexterm2:[+log-debug?+] all accept one argument, the log object, and return true if a log message at the given 
level would be output by the log object.

=== Example

The following example illustrates how these functions may be used:

[source,lisp]
----
(define log (new-logger "log1.txt"))      ; <1>
(log-level log 'info)                     ; <2>
(log-info log "some information logged")  ; <3>
(log-debug log "this will be ignored")    ; <4>
(log-level log 'debug)                    ; <5>
(log-debug log "but this included")       ; <6>
(log-close log)                           ; <7>
----
<1> Create a new logger, output to the given file
<2> Sets the log level to "info"
<3> Outputs a line at "info" level, which will be output
<4> Tries to output a line at "debug" level, but this will be ignored as it is lower than the set level
<5> Sets the log level to "debug"
<6> And now the log message at "debug" level will be output
<7> Finally, close the logger, which closes the file port it opened

The output from the above example is sent to the file "log1.txt", which contains two lines.  Notice the log level 
precedes each message.

----
$ more log1.txt 
info: some information logged
debug: but this included
----

== Series: +(import (robin series))+

indexterm:[series]
A functional implementation of Richard Waters' Lisp Series package.

== SRFI 64 Utilities: +(import (robin srfi64-utils))+

Some convenience functions for unit testing with SRFI 64.

=== test-approx-same

indexterm2:[+test-approx-same+] checks if two inexact numbers are within a given bound.  This is 
the same as +test-approximate+ except that the tolerance is optional, and defaults to 0.001.

----
#|kawa:32|# (test-approx-same 1 1.001)
#|kawa:33|# (test-approx-same 1 1.001 0.0001)
robin/srfi64-utils.sld:65: FAIL
----

=== test-compare

indexterm2:[+test-compare+] checks if two given items satisfy the given comparison procedure.

This is useful for testing equality of more complex data.  For example, we might want to check if 
just the first item of sublists are the same:

----
#|kawa:34|# (import (srfi 1))
#|kawa:41|# (define (equal-cars? i1 i2) (every (lambda (l1 l2) (equal? (car l1) (car l2))) i1 i2))
#|kawa:42|# (test-compare equal-cars? '((1 2) (3 4)) '((1 5) (3 6)))
#|kawa:43|# (test-compare equal-cars? '((1 2) (3 4)) '((1 5) (4 6)))
robin/srfi64-utils.sld:69: FAIL
----

=== test-no-error

indexterm2:[+test-no-error+] is used to confirm that a piece of code has _not_ thrown an error.
In the following example, the first line raises an +error+, and so the test fails.
The second line does not raise an +error+, and so the test passes.

----
#|kawa:27|# (test-no-error (if (zero? 0) (error "") #t))
robin/srfi64-utils.sld:55: FAIL
#|kawa:28|# (test-no-error (if (zero? 1) (error "") #t))
#|kawa:29|# 
----

== Statistics: +(import (robin statistics))+

indexterm:[statistics]  A library of statistical functions to compute 
information about sets of data.

=== mean

Computes the arithmetic indexterm2:[+mean+] of a list of numbers. 

=== arithmetic-mean

indexterm:[arithmetic-mean] Same as +mean+.

=== geometric-mean

indexterm2:[+geometric-mean+]

=== harmonic-mean

indexterm2:[+harmonic-mean+]


=== median

indexterm2:[+median+]

=== mode

indexterm2:[+mode+]

=== percentile

indexterm2:[+percentile+]

=== population-standard-deviation

indexterm2:[+population-standard-deviation+]

=== population-variance

indexterm2:[+population-variance+]

=== standard-deviation

indexterm2:[+standard-deviation+]

=== variance

indexterm2:[+variance+]


== Text: +(import (robin text))+

indexterm:[text] The text library contains some functions for working with 
larger strings or lists of strings.

=== words->with-commas

indexterm2:[+words->with-commas+] is a function taking a list of strings and 
adding commas in between the items up to the last item, which is preceded 
by an "and".  For example:

[source,lisp]
----
> (words->with-commas '())
""
> (words->with-commas '("apple"))
"apple"
> (words->with-commas '("apple" "banana"))
"apple and banana"
> (words->with-commas '("apple" "banana" "chikoo"))
"apple, banana and chikoo"
> (words->with-commas '("apple" "banana" "chikoo" "damson"))
"apple, banana, chikoo and damson"
> (words->with-commas '("apple" "banana" "chikoo" "damson") #t)
"apple, banana, chikoo, and damson"
----

An optional second argument controls whether the final "and" should be 
preceded by a comma.  The default is not to have the comma.

=== word-wrap

indexterm2:[+word-wrap+]

== Repackaged or Ported Libraries

Most of the libraries available in this collection have been repackaged or
ported from earlier versions of Scheme, or Lisp, to work under R7RS Scheme
implementations.  Modifications have been kept to a minimum to make the code
work.  Test scripts and examples are available for some parts of these
libraries and may be examined for ideas on how each library works. 

=== Natural Language Tool Kit: +(import (nltk NNN))+

indexterm:[nltk]
A repackaging of libraries from the Natural Language ToolKit: https://sourceforge.net/projects/snltk/[]

*    dfsa
*    lang-en
*    lang-hr
*    n-grams
*    sequence
*    vectorspace

(Not the +cgi+ package, as the necessary support libraries are not present.)

These libraries support natural-language processing tasks, such as dividing text into n-grams, analysing or 
displaying the n-grams, and working with a deterministic finite-state automaton.

Some tests and examples are provided, but otherwise this collection needs documenting.

=== Purely Functional Data Structures: +(import (pfds NNN))+

indexterm:[pfds]
A repackaging of _Purely Functional Data Structures_, originally written for R6RS Scheme: https://github.com/ijp/pfds[]

These data structures implement algorithms from a variety of sources (see the README at above link).

*    bounded-balance-tree
*    deque
*    difference-list
*    fingertree
*    hash-array-mapped-trie
*    heap
*    priority-search-queue
*    queue
*    sequence
*    set

And, to support implementation:

*    alist
*    bitwise
*    lazy-list
*    list-helpers
*    vector

Some tests and examples are provided, but otherwise this collection needs documenting.

=== R6RS: +(import (r6rs NNNN))+

indexterm:[r6rs]
As many of the libraries have been ported from R6RS implementations, they depend on some 
R6RS functionalities - particularly fixnum arithmetic and bytevectors.  Some of these 
have been taken from http://snow-fort.org[] in support of the repackaging (particularly for Weinholt).

=== Rebottled

indexterm:[rebottled]
Some libraries ported from older Scheme versions or Common Lisp: these libraries are individual 
or very few files.

==== CL-PDF: +(import (rebottled cl-pdf))+

indexterm:[cl-pdf]
Originally written for Common Lisp by Marc Battyani, this library was then ported to Scheme 
by Bruce Butterfield.  Packaged for R7RS Scheme by myself.

The library allows us to construct and output PDF documents.  The following example 
displays two repeated blocks of text and a title in a variety of fonts, sizes and 
positions in the document.

[source,lisp]
----
(define (ex1)
  (pdf:with-document-to-file 
    "ex1.pdf"
    (let ((helvetica (pdf:build-font "Helvetica"))
          (courier (pdf:build-font "Courier")))
      (pdf:with-page
        (pdf:in-text-mode
          (pdf:set-font (pdf:font-name helvetica) 36)
          (pdf:move-text 100 750)
          (pdf:draw-text "scm-pdf: Example 1"))
        (pdf:in-text-mode
          (dotimes (i 25)
            (pdf:set-font (pdf:font-name helvetica) (* i 1.5))
            (pdf:move-text (+ i 5) (+ i 10))
            (pdf:draw-text "Helvetica")))
        (pdf:in-text-mode
          (dotimes (i 25)
            (pdf:set-font (pdf:font-name courier) (* i 1.5))
            (pdf:move-text (+ i 5) (- 50 (+ i 10)))
            (pdf:draw-text "Courier")))))))
----            

This library needs documentation, and some helper functions to layout larger blocks of text.

==== Portable Regular Expressions: +(import (rebottled pregexp))+

indexterm:[pregexp]
Written by Dorai Sitaram, this library is documented at:
http://ds26gte.github.io/pregexp/index.html[]

==== Quaternions: +(import (rebottled quaternions))+

indexterm:[quaternions]
Written by Dorai Sitaram, this library is documented at:
http://www.ccs.neu.edu/home/dorai/squat/squat.html[]

The quaternions library extends the Scheme numeric tower.  

==== Schelog: +(import (rebottled schelog))+

indexterm:[schelog]
Written by Dorai Sitaram, this library is documented at:
https://ds26gte.github.io/schelog/index.html[]

=== SLIB: +(import (slib NNNN))+

indexterm:[slib]
SLIB is a collection of packages of Scheme code, mostly written by Aubrey
Jaffer, but some collected from other sources.  Looking through the files, some
of the original dates go back to 1991, and the precedence parser into 1989.  A
number of ideas now found in Scheme and captured in the SRFIs can be traced
back to SLIB.  The repackaged files in +r7rs-libs+ have been adapted to work
with R7RS Scheme implementations: using R7RS functionality, the library system,
and operations now found in SRFIs.  

There are 91 libraries within the R7RS SLIB collection.  These fall within four main 
groups of functionality:

. Textual Conversion Packages, including a parser, I/O routines, html and xml processing, 
  pretty-printing of Scheme objects, and procedures to handle times and dates.
. Mathematical Libraries, including prime numbers, some random number distributions, plotting 
  functions (to text and eps), root/limit finding libraries and a 3D modelling suite.
. Database Packages, which implement a relational database system, and a library for weighted
  trees.
. Other Packages
.. Data Structures: for enhancing arrays, working with pnm files, an object system and queues.
.. Sorting and Searching: trees, chapter-order, topological sort, along with some space filling 
   curves and sequence comparisons.
.. Other Procedures: a library of metric units for computing conversions.

See documentation at http://people.csail.mit.edu/jaffer/slib[], but SLIB could do with 
further examples and third-party descriptions.

The github page for +r7rs-libs+ and the wiki, https://github.com/petercrlane/r7rs-libs/wiki[],
provide additional information about SLIB and its conversion for use as R7RS libraries.  

The "examples" and "tests" directories provide (some) examples of using SLIB.


=== SRFI: +(import (srfi NN))+

indexterm:[srfi] The +r7rs-libs+ include some SRFIs for Chibi and Kawa.  These
are provided solely to provide support for the above libraries.  Although
mostly complete in themselves, SRFI-64, for example, only provides those
functions needed in the test suites to support Chibi, wrapping 
equivalent +(chibi test)+ functions.

For documentation on the SRFIs, see http://srfi.schemers.org/final-srfis.html[]

=== Weinholt Industria: +(import (weinholt NNNN))+

indexterm:[weinholt]
This collection is still in process of being repackaged.  It contains a collection of algorithms for 
working with compression algorithms, performing cryptography, and interacting with networks.  

Documentation is available at: https://weinholt.se/industria/manual/[]

See https://github.com/petercrlane/r7rs-libs[] for information on which libraries are currently available.

[index]
== Index

