== SLIB

indexterm:[slib]
SLIB is a collection of packages of Scheme code, mostly written by Aubrey
Jaffer, but some collected from other sources.  Looking through the files, some
of the original dates go back to 1991, and the precedence parser into 1989.  A
number of ideas now found in Scheme and captured in the SRFIs can be traced
back to SLIB.  The repackaged files in +r7rs-libs+ have been adapted to work
with R7RS Scheme implementations: using R7RS functionality, the library system,
and operations now found in SRFIs.  

SLIB's official documentation is available at http://people.csail.mit.edu/jaffer/slib[]

There are 91 libraries within the R7RS SLIB collection.  These fall within four main 
groups of functionality:

. Textual Conversion Packages, including a parser, I/O routines, html and xml processing, 
  pretty-printing of Scheme objects, and procedures to handle times and dates.
. Mathematical Libraries, including prime numbers, some random number distributions, plotting 
  functions (to text and eps), root/limit finding libraries and a 3D modelling suite.
. Database Packages, which implement a relational database system, and a library for weighted
  trees.
. Other Packages
.. Data Structures: for enhancing arrays, working with pnm files, an object system and queues.
.. Sorting and Searching: trees, chapter-order, topological sort, along with some space filling 
   curves and sequence comparisons.
.. Other Procedures: a library of metric units for computing conversions.

The github page for +r7rs-libs+ and the wiki, https://github.com/petercrlane/r7rs-libs/wiki[],
provide additional information about SLIB and its conversion for use as R7RS libraries.  

The "examples" and "tests" directories provide (some) examples of using SLIB.  Limited 
documentation for some of the libraries follows.

=== Charplot: +(import (slib charplot))+

This library provides a way to quickly visualise some data in graphical or histogram 
form from the REPL or command-line interface.  There are two basic functions: +histograph+ 
and +plot+, the latter drawing graphs of data or functions.

==== charplot:dimensions

This parameter allows you to change the size of display.  The dimensions are a two-valued 
list: the height and width in characters.  Example below.

==== histograph

indexterm2:[+histograph+] is used to plot histograms of numeric data.  Given a list or vector 
of numbers, it will arrange them into a suitable set of bins and display:

----
> (histograph '(1 1 2 3 5 5 5 7 8 9) "sample")
           ________________________________________________________________   
          |                                                                |  
          |                                                                |  
         3|-                       I                                       |  
          |                        I                                       |  
          |                        I                                       |  
       2.5|-                       I                                       |  
          |                        I                                       |  
          |                        I                                       |  
         2|-I                      I                                       |  
          | I                      I                                       |  
          | I                      I                                       |  
       1.5|-I                      I                                       |  
          | I                      I                                       |  
          | I                      I                                       |  
         1|-I     I     I          I           I     I     I               |  
          | I     I     I          I           I     I     I               |  
          | I     I     I          I           I     I     I               |  
       0.5|-I     I     I          I           I     I     I               |  
          | I     I     I          I           I     I     I               |  
          | I     I     I          I           I     I     I               |  
         0|-IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII---------------|  
          |._____:_____._____:_____._____:_____._____:_____._____:_____.___|  
  sample         2           4           6           8           10           

> (charplot:dimensions '(10 50))
> (histograph '(1 1 2 3 5 5 5 7 8 9) "sample")
           ___________________________________   
         3|-               I                  |  
          |                I                  |  
         2|-I              I                  |  
          | I              I                  |  
         1|-I   I   I      I       I   I   I  |  
          | I   I   I      I       I   I   I  |  
         0|-IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII--|  
          |_.____:____.____:____.____:____.___|  
  sample        2.5        5        7.5          
> 
----

==== plot

indexterm2:[+plot+] can be used in two ways: to display a function, or to display some data.

.Plotting a function

+plot+ will plot the values of a single argument function (taking and returning a number).
The function should be given as the first argument.  The second and third arguments specify the 
range of x values over which to plot the graph - be careful of infinite values from your 
function, which will crash +plot+.  An optional fourth argument specifies how many points 
to plot along the range of x values.

----
> (plot (lambda (x) (* x x x)) -5 5)
           _________________________________________________________________   
       140|-                              :                                 |  
          |                               :                                 |  
       120|-                              :                             *   |  
          |                               :                            *    |  
       100|-                              :                           *     |  
          |                               :                          *      |  
        80|-                              :                         *       |  
          |                               :                       **        |  
        60|-                              :                      *          |  
          |                               :                    **           |  
        40|-                              :                   *             |  
          |                               :                 ***             |  
        20|-                              :               **                |  
          |                  ***          :          *****                  |  
         0|---------------------*********************-----------------------|  
          |                **             :                                 |  
       -20|-             **               :                                 |  
          |           ***                 :                                 |  
       -40|-          *                   :                                 |  
          |         **                    :                                 |  
       -60|-       *                      :                                 |  
          |      **                       :                                 |  
       -80|-    *                         :                                 |  
          |    *                          :                                 |  
      -100|-  *                           :                                 |  
          |  *                            :                                 |  
      -120|-*                             :                                 |  
          |_._____:_____._____:_____._____:_____._____:_____._____:_____.___|  
                  -4          -2          0           2           4           

> (plot (lambda (x) (* x x x)) -5 5 30)
           _________________________________________________________________   
       140|-                              :                                 |  
          |                               :                                 |  
       120|-                              :                             *   |  
          |                               :                                 |  
       100|-                              :                           *     |  
          |                               :                                 |  
        80|-                              :                         *       |  
          |                               :                                 |  
        60|-                              :                       *         |  
          |                               :                     *           |  
        40|-                              :                   *             |  
          |                               :                 *               |  
        20|-                              :               *                 |  
          |                    *          :          * *                    |  
         0|----------------------*-*-*-*-*:*-*-*-*-*------------------------|  
          |                  *            :                                 |  
       -20|-              *               :                                 |  
          |             *                 :                                 |  
       -40|-          *                   :                                 |  
          |         *                     :                                 |  
       -60|-      *                       :                                 |  
          |                               :                                 |  
       -80|-    *                         :                                 |  
          |                               :                                 |  
      -100|-  *                           :                                 |  
          |                               :                                 |  
      -120|-*                             :                                 |  
          |_._____:_____._____:_____._____:_____._____:_____._____:_____.___|  
                  -4          -2          0           2           4          
----

.Plotting some data

This second form of +plot+ directly plots a list or vector of pairs of (x, y)
coordinates. Second and third arguments give labels to the two axes.

----
> (define data (map (lambda (x) (list x (* x x x))) (iota 11 -5)))
> data
((-5 -125) (-4 -64) (-3 -27) (-2 -8) (-1 -1) (0 0) (1 1) (2 8) (3 27) (4 64) (5 125))
> (plot data "x-values" "y-values")
 y-values  _________________________________________________________________   
       140|-                              :                                 |  
          |                               :                                 |  
       120|-                              :                             *   |  
          |                               :                                 |  
       100|-                              :                                 |  
          |                               :                                 |  
        80|-                              :                                 |  
          |                               :                                 |  
        60|-                              :                       *         |  
          |                               :                                 |  
        40|-                              :                                 |  
          |                               :                 *               |  
        20|-                              :                                 |  
          |                   *           :           *                     |  
         0|-------------------------*-----*-----*---------------------------|  
          |                               :                                 |  
       -20|-                              :                                 |  
          |             *                 :                                 |  
       -40|-                              :                                 |  
          |                               :                                 |  
       -60|-      *                       :                                 |  
          |                               :                                 |  
       -80|-                              :                                 |  
          |                               :                                 |  
      -100|-                              :                                 |  
          |                               :                                 |  
      -120|-*                             :                                 |  
          |_._____:_____._____:_____._____:_____._____:_____._____:_____.___|  
 x-values         -4          -2          0           2           4            

----

=== Database

indexterm:[database] indexterm:[relational database]
SLIB includes a relational database system, written entirely in Scheme.  This is a complex 
and inter-related set of libraries.  The following example (from "slib-examples/db-1.sps") 
provides an introduction to creating, opening and using a simple database.  

.Note
****
The database system stores information in files.  It also sets up locks on those 
files to prevent multiple users trying to change the same data.  The code has been 
tested under Linux, but requires further tests and possible modification on other 
operating systems.

If your application fails with any errors, it is possible the lock files will remain 
and must be deleted before you can access the database again: the lock files start 
".$" and ".#", and are thus hidden on Linux and similar systems.
****

More information on SLIB's database system is available at: http://people.csail.mit.edu/jaffer/slib/Using-Databases.html[].
After understanding the example below, work through section 6.1.2 on Table Operations.  

==== Creating a database

A database can be created using one or more "backends".  Currently, only an association list 
backend is supported, as provided by +(slib alist-table)+.  A database is created to a given filename:

[source,scheme]
----
(import (scheme base)
        (slib databases)
        (slib alist-table))

(define db (create-database "mydb" 'alist-table))
----

The above code imports the necessary libraries, and creates a database in the file "mydb" using 
an association-list backend.  A reference to this database is stored in +db+.

Next, the database can be opened:

[source,scheme]
----
(define rdb (open-database! db))
----

As we will see below, a database can be opened using either the database reference from the +create-database+ 
command, or from the filename.  So +(open-database! "mydb")+ works just as well.

Databases can be opened in _mutable_ or _immutable_ modes: opened to be changed, or just for reading.  
The exclamation mark ! indicates that the database is mutable.  

Data in a database is stored within _tables_.  Before we can use our new database, we need to create 
at least one table.  A table is defined from three elements:

. its _name_
. its _primary key field(s)_
. its _other fields_

In our example, we make an example with name "testit", a single primary key "id", and two fields "first" and "second".
Each field is defined with an associated type (allowed types are described in the
http://people.csail.mit.edu/jaffer/slib/Catalog-Representation.html#Catalog-Representation[online] documentation).  
In this case, our "id" field will be a number, and the two other fields strings.

The basic definition is: 

----
(testit                                  ; the table name
  ((id number))                          ; list of primary key field (name type) pairs
  ((first string) (second string)))      ; list of other field (name type) pairs
----

When defining a table, we can also provide a list of data to add.  The data are simply given in rows, with values for all fields:

----
((1 "Peter" "Lane")   ; row 1: (id first second)
 (2 "Joe" "Smith"))   ; row 2: (id first second)
----

Putting the definitions together, the following line of code creates the +testit+ table, and adds some initial data:

[source,scheme]
----
(define-tables rdb '(testit ((id number)) ((first string) (second string))
                            ((1 "Peter" "Lane")
                             (2 "Joe" "Smith"))))
----

Finally, don't forget to close the database, which ensures everything is saved on disk:

[source,scheme]
----
(close-database rdb)
----

You can examine the file "mydb" to read the definition and data.

==== Working with a database

Databases should only need constructing once.  Afterwards, you will open and work with the 
existing file.  To open an existing database, you need to know its filename:

[source,scheme]
----
(define mydb (open-database! "mydb"))   ; open a mutable database
----

To access information in a table, you need to extract the table of interest:

[source,scheme]
----
(define table (open-table! mydb 'testit))
----

If you were to examine +table+, you would find it is a _procedure_.  The table 
procedure takes an operation definition as its argument, and returns a new procedure 
to perform that operation on some data.

For example, if we wish to retrieve a row of data.  The operation definition is +'row:retrieve+.
The returned procedure then takes the primary key(s) to locate in the database:

[source,scheme]
----
((table 'row:retrieve) 1)   ; returns the row with id 1: (1 "Peter" "Lane")
----

Try displaying all rows (note, the third case will return +#f+):

[source,scheme]
----
(display "Retrieving 1: ") (display ((table 'row:retrieve) 1)) (newline)
(display "Retrieving 2: ") (display ((table 'row:retrieve) 2)) (newline)
(display "Retrieving 3: ") (display ((table 'row:retrieve) 3)) (newline)
----

A new row can be inserted in a similar way:

[source,scheme]
----
((table 'row:insert) '(3 "Jane" "Wheeler"))
----

Further row operations exist to update and delete.

Operations are also available to work on multiple rows.  A useful case is +for-each-row+:

[source,scheme]
----
((table 'for-each-row) (lambda (row) (display "Row: ") (display row) (newline)))
----

Finally, don't forget to close the database, which ensures everything is saved on disk:

[source,scheme]
----
(close-database mydb)
----

=== Dynamic: +(import (slib dynamic))+

indexterm:[dynamic]
Provides a kind of name-value store, which can be accessed globally.  (This is 
essentially the same as R7RS parameters, with a different syntax.)

indexterm2:[+make-dynamic+] creates a dynamic object wrapping a given object.

indexterm2:[+dynamic?+] returns true only if the given object is a dynamic.

indexterm2:[+dynamic-ref+] returns the value of a given dynamic object.

indexterm2:[+dynamic-set!+] changes the value of the given dynamic object.

indexterm2:[+call-with-dynamic-binding+] temporarily rebinds a given dynamic 
object to a new value within the given procedure.

[source,scheme]
----
(let ((x (make-dynamic 'a))         ; <1>
      (y (make-dynamic 'b)))
  (dynamic? x)                      ; <2>
  (eq? 'a (dynamic-ref x))          ; <3>
  (eq? 'b (dynamic-ref y))
  (dynamic-set! x 'c)               ; <4>
  (call-with-dynamic-binding x 'd   ; <5>
    (lambda () (eq? 'd (dynamic-ref x))))
  (eq? 'c (dynamic-ref x)))         ; <6>
----
<1> Names +x+ as the dynamic object with value +'a+
<2> Returns +#t+ as +x+ is a dynamic object
<3> Retrieves the value of the given dynamic object, and checks it is correct
<4> Changes the value of the given dynamic object
<5> Within the +lambda+ +x+ is now bound to +'d+
<6> and +x+ reverts to holding +'c+ after the call

=== Factor: +(import (slib factor))+

Functions for testing if numbers are primes, generating prime numbers, and to factor numbers.

These functions use the Solovay-Strassen primality test:

* Robert Solovay and Volker Strassen, A Fast Monte-Carlo Test for Primality,
  _SIAM Journal on Computing_, 1977, pp 84-85. 

==== factor

indexterm2:[+factor+] takes one argument and returns a list of the prime factors of that 
number: the numbers are in no guaranteed order.

[source,scheme]
----
> (factor 5)
(5)
> (factor 100)
(5 5 2 2)
----

==== jacobi-symbol

The indexterm2:[+jacobi-symbol+] is used in modular arithmetic with one application, as here, 
being tests for primality.  The function returns 0, -1 or 1 given two integers.

[source,scheme]
----
> (jacobi-symbol 15 7)
1
> (jacobi-symbol 63 7)
0
> (jacobi-symbol 7 15)
-1
----

==== prime:trials

indexterm2:[+prime:trials+] controls the likelihood that +prime?+ will accept a composite 
number as a prime.  The probability is 2^(- +prime:trials+) 

+prime:trials+ is a parameter object, so you can change it to a higher value, if required:

[source,scheme]
----
> (prime:trials)
30
> (prime:trials 100)
> (prime:trials)
100
----

==== prime?

indexterm2:[+prime?+] returns true or false depending on if the given number passes the 
Solovay-Strassen primality test.

[source,scheme]
----
> (prime? 17)
#t
> (prime? 1)
#f
----

==== primes<

indexterm2:[+primes<+] accepts two arguments: a start value and a count.  It returns a list 
of +count+ prime numbers less than the start value.

[source,scheme]
----
> (primes< 18 2)
(13 17)
----

==== primes>

indexterm2:[+primes>+] accepts two arguments: a start value and a count.  It returns a list 
of +count+ prime numbers greater than the start value.

[source,scheme]
----
> (primes> 18 2)
(19 23)
----

include::slib-format.txt[]

include::slib-soundex.txt[]

include::slib-xml-parse.txt[]

=== Time/Date 

The R7RS standard has a library +(scheme time)+ which contains three functions:
+current-second+, to obtain the current time in seconds since 1/1/1970;
+current-jiffy+, which returns an implementation-defined fraction of a second
from an implementation-specific start point; and +jiffies-per-second+, which
returns the implementation-specific number of "jiffies" per second.  The
libraries  provided in SLIB help convert to and from larger units of time (such
as days and years), and also take account of time-zones.  indexterm2:[SRFI 19]
provides a useful standard library for working with dates and times, where
available.

SLIB provides a small set of libraries for managing times, dates and time-zones.  
These reflect Lisp and Posix treatments of time.  The libraries use a variety of 
data formats:

Calendar Time:: number of seconds since 1st January 1970 (as used by R7RS +current-second+)
Decoded Time:: nine values for second, minute, hour, date, month, year, day-of-week, daylight-saving-time? and time-zone.  Note that months start with January = 1, days of week start with Monday = 0
TM Time:: (C's +struct tm+) nine values for seconds, minutes, hours, date, month, year, day-of-week, days-in-year, daylight-saving-time?.  Note that months start with January = 0, years start with 1900 = 0, days of week start with Sunday = 0
Universal Time:: number of seconds since 1st January 1900

The libraries themselves are:

* +(slib common-lisp-time)+: From Lisp, using Decoded Time and Universal Time.
* +(slib posix-time)+: From C/Posix, using TM Time and Calendar Time.
* +(slib time-core)+: main time conversion functions
* +(slib time-zone)+: computes time-zones and daylight-saving times from the time-zone 
  environment variable or files
* +(slib tzfile)+: reads from a time-zone file

Time zone information is ultimately read via +tzfile+ which looks for either the
environment variable "TZ" or in one of a specified set of paths.  (This
currently does not appear to support Windows.)

None of these libraries handles leap seconds.

==== +(slib common-lisp-time)+

indexterm:[common-lisp-time]
These functions are based on those in Common Lisp to convert between 
Decoded Time and Universal Time.

indexterm2:[+get-decoded-time+] returns the current time in Decoded Time format,
as nine values.  +(get-decoded-time)+ is short for +(decode-universal-time (get-universal-time))+.

[source,scheme]
----
> (get-decoded-time)
((values) 58 15 18 18 4 2017 1 #f 0)
----

indexterm2:[+get-universal-time+] returns the current time of day as a single
integer in _Universal Time_ format representing the number of seconds since
1/1/1900: note for comparison how R7RS's +(current-second)+ returns a much smaller 
value (_Calendar Time_, the number of seconds since 1/1/1970).

[source,scheme]
----
> (get-universal-time)
3701527370.61162
> (current-second)
1492540922.30859
----

indexterm2:[+decode-universal-time+] converts a universal time (with an optional time-zone) into the nine values of Decoded Time format.

[source,scheme]
----
> (decode-universal-time (get-universal-time))
((values) 41 2 18 18 4 2017 1 #f 0)
----

The optional time-zone is the number of hours away from GMT.  This is backwards from what you 
might expect: British Summer Time, one hour ahead of GMT, is given by -1.

[source,scheme]
----
> (decode-universal-time (get-universal-time) -1)   ; current time in London (BST = GMT+1)
((values) 26 4 19 18 4 2017 1 #f -1)
> (decode-universal-time (get-universal-time) -5.5) ; current time in New Delhi (GMT+5.5)
((values) 54 35 23 18 4 2017 1 #f -11/2)
----

indexterm2:[+encode-universal-time+] takes the _first six_ values of Decoded Time 
format, and returns a Universal Time representation. 

[source,scheme]
----
> (encode-universal-time 8 50 21 18 3 2017)
3698862608.0
----

==== +(slib core-time)+

indexterm:[core-time]
A collection of functions to help in time conversions based around TM Time.  

indexterm2:[+current-time+] is the same as +current-second+.  This is the +Calendar Time+, 
defined relative to 1/1/1970.  

[source,scheme]
----
> (current-time)
1492540922.30859
----

indexterm2:[+difftime+] subtracts two times, given as seconds.

indexterm2:[+leap-year?+] returns true if given year is a leap-year, false otherwise.

[source,scheme]
----
> (leap-year? 2000)
#t
> (leap-year? 2004)
#t
> (leap-year? 1900)
#f
----

indexterm2:[+offset-time+] adds two times together, given as seconds.

indexterm2:[+time:gmtime+] takes a time in seconds and returns the _TM Time_ information, 
assuming the location is GMT:

[source,scheme]
----
> (time:gmtime (current-time))
#(39 45 18 18 3 117 2 107 0 0 "GMT")            ; <1>
----
<1> time is 18:45 39s, 18 is the date, month is April (3), year is 2017 (117+1900), 
    day of week is Tuesday (2), 108 days from 1st January.  The last 0 is for
    the offset due to the time zone.

Note that +time:gmtime+ calls indexterm2:[+time:split+]: +(time:gmtime tm)+ = +(time:split tm 0 0 "GMT")+

==== +(slib posix-time)+

indexterm:[posix-time] This library provides data structures and functions similar to those 
in C's "time.h".

indexterm2:[+asctime+] converts a _TM time_ into a string representation:

[source,scheme]
----
> (asctime (gmtime (current-time)))
"Tue Apr 18 20:18:15 2017\n"
----

indexterm2:[+gmtime+] takes a Calendar time (in seconds) and returns the _TM Time_ information, assuming
the location is GMT (the same as +time:gmtime+).

indexterm2:[+gtime+] is short for +(asctime (gmtime ..))+

[source,scheme]
----
> (gtime (current-time))
"Tue Apr 18 20:38:28 2017\n"
----

indexterm2:[+localtime+] converts a Calendar time into a _TM Time_.  An optional second 
argument specifies the time zone.

[source,scheme]
----
> (localtime (current-time) (read-tzfile "Asia/Calcutta"))
#(51 16 2 19 3 117 3 108 0 -19800 #(73 83 84))
> (localtime (current-time))
#(8 47 21 18 3 117 2 107 1 -3600 #(66 83 84))
----

indexterm2:[+ctime+] is short for +(asctime (localtime ...))+

[source,scheme]
----
> (ctime (current-time))
"Tue Apr 18 21:44:32 2017\n"
> (ctime (current-time) (read-tzfile "Asia/Calcutta"))
"Wed Apr 19 02:16:20 2017\n"
----

indexterm2:[+mktime+] converts the _TM Time_ to Calendar time:

[source,scheme]
----
> (current-time)
1492548597.89966
> (localtime (current-time))
#(8 50 21 18 3 117 2 107 1 -3600 #(66 83 84))
> (mktime (localtime (current-time)))
1492552289.0
----

indexterm2:[+gmktime+] is the same as +mktime+, except it assumes a GMT time zone.

==== +(slib time-zone)+

indexterm:[time-zone]
indexterm2:[+read-tzfile+] takes a path or, if given +#f+, uses a known path to a time-zone file.
The function then calls +tzfile:read+ from +(slib tzfile)+ and returns the result (see below).

+read-tzfile+ is used by +time-zone+ to read the specific time-zone information for a given 
locality:

[source,scheme]
----
> (read-tzfile "Asia/Dili")
#(tz:file "/usr/share/zoneinfo/Asia/Dili" #(#(#(76 77 84) 30140 #f #f #f) #(#(84 76 84) 28800 #f #f #f) #(#(74 83 84) 32400 #f #f #f) #(#(84 76 84) 32400 #f #f #f) #(#(87 73 84 65) 28800 #f #f #f) #(#(84 76 84) 32400 #f #f #f)) #() #(-2147483648 -1830414140 -879152400 -766054800 199897200 969120000) #(0 1 2 3 4 3))
> (read-tzfile "GMT")
#(tz:file "/usr/share/zoneinfo/GMT" #(#(#(71 77 84) 0 #f #f #f)) #() #() #())
----

(Following +string->+ functions rely on sscanf, and currently do not work:
indexterm2:[+string->transition-day-time+],
indexterm2:[+string->transition-time+],
indexterm2:[+string->time-offset+],
indexterm2:[+string->time-zone+])

indexterm2:[+time-zone+] will either:

* return its argument, if it is a vector (i.e. already a time-zone description)
* use +read-tzfile+ if the argument is +#f+ or a time-zone file name prefixed with ":"
* use +string->time-zone+ if the argument is a string without ":" at start (CURRENTLY SCANF FAILS)

[source,scheme]
----
> (time-zone #(tz:file "/usr/share/zoneinfo/GMT" #(#(#(71 77 84) 0 #f #f #f)) #() #() #()))
#(tz:file "/usr/share/zoneinfo/GMT" #(#(#(71 77 84) 0 #f #f #f)) #() #() #())
> (time-zone ":Asia/Dili")
#(tz:file "/usr/share/zoneinfo/Asia/Dili" #(#(#(76 77 84) 30140 #f #f #f) #(#(84 76 84) 28800 #f #f #f) #(#(74 83 84) 32400 #f #f #f) #(#(84 76 84) 32400 #f #f #f) #(#(87 73 84 65) 28800 #f #f #f) #(#(84 76 84) 32400 #f #f #f)) #() #(-2147483648 -1830414140 -879152400 -766054800 199897200 969120000) #(0 1 2 3 4 3))
----

==== +(slib tzfile)+

indexterm:[tzfile]
There is only one exported function: indexterm2:[+tzfile:read+].  This function reads time-zone 
information from a system-specified file.  For example, on Linux, the file may be "/etc/localtime":

[source,scheme]
----
> (import (slib tzfile))
> (tzfile:read "/etc/localtime")
("/etc/localtime" #(#(#(76 77 84) -75 #f #f #f) #(#(66 83 84) 3600 #t #t #f)
#(#(71 77 84) 0 #f #t #f) #(#(66 68 83 84) 7200 #t #t #f) #(#(66 83 84) 3600 #f
#f #f) #(#(66 83 84) 3600 #t #t #t) #(#(71 77 84) 0 #f #t #t) #(#(71 77 84) 0
#f #f #f)) #() #(-2147483648 -1691964000 -1680472800 -1664143200 -1650146400
-1633903200 -1617487200 -1601848800 -1586037600 -1570399200 -1552168800
-1538344800 -1522533600 -1507500000 -1490565600 -1473631200 -1460930400
-1442786400 -1428876000 -1410732000 -1396216800 -1379282400 -1364767200
-1348437600 -1333317600 -1315778400 -1301263200 -1284328800 -1269813600
-1253484000 -1238364000 -1221429600 -1206914400 -1189980000 -1175464800
-1159135200 -1143410400 -1126476000 -1111960800 -1095631200 -1080511200
-1063576800 -1049061600 -1032127200 -1017612000 -1001282400 -986162400
-969228000 -950479200 -942012000 -904518000 -896050800 -875487600 -864601200
-844038000 -832546800 -812588400 -798073200 -781052400 -772066800 -764805600
-748476000 -733356000 -719445600 -717030000 -706748400 -699487200 -687996000
-668037600 -654732000 -636588000 -622072800 -605743200 -590623200 -574293600
-558568800 -542239200 -527119200 -512604000 -496274400 -481154400 -464220000
-449704800 -432165600 -417650400 -401320800 -386200800 -369266400 -354751200
-337816800 -323301600 -306972000 -291852000 -276732000 -257983200 -245282400
-226533600 -213228000 -195084000 -182383200 -163634400 -150933600 -132184800
-119484000 -100735200 -88034400 -68680800 -59004000 -37242000 57722400 69818400
89172000 101268000 120621600 132717600 152071200 164167200 183520800 196221600
214970400 227671200 246420000 259120800 278474400 290570400 309924000 322020000
341373600 354675600 372819600 386125200 404269200 417574800 435718800 449024400
467773200 481078800 499222800 512528400 530672400 543978000 562122000 575427600
593571600 606877200 625626000 638326800 657075600 670381200 688525200 701830800
719974800 733280400 751424400 764730000 782874000 796179600 814323600 820454400
828234000 846378000 859683600 877827600 891133200 909277200 922582800 941331600
954032400 972781200 985482000 1004230800 1017536400 1035680400 1048986000
1067130000 1080435600 1099184400 1111885200 1130634000 1143334800 1162083600
1174784400 1193533200 1206838800 1224982800 1238288400 1256432400 1269738000
1288486800 1301187600 1319936400 1332637200 1351386000 1364691600 1382835600
1396141200 1414285200 1427590800 1445734800 1459040400 1477789200 1490490000
1509238800 1521939600 1540688400 1553994000 1572138000 1585443600 1603587600
1616893200 1635642000 1648342800 1667091600 1679792400 1698541200 1711846800
1729990800 1743296400 1761440400 1774746000 1792890000 1806195600 1824944400
1837645200 1856394000 1869094800 1887843600 1901149200 1919293200 1932598800
1950742800 1964048400 1982797200 1995498000 2014246800 2026947600 2045696400
2058397200 2077146000 2090451600 2108595600 2121901200 2140045200) #(2 1 2 1 2
1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 3 1 3 1 3 1 3 1 3 1 2 1 2 1 3 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 4 6 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1
2 1 2 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 7 5 6 5 6 5 6
5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6
5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6))
----

=== +(slib uri)+

A package for creating, decoding and testing various forms of URI.

indexterm2:[+absolute-path?+] returns true if the given filename is an absolute
path, or false if it depends on the current directory.

[source,scheme]
----
> (absolute-path? "/usr/local/bin/scheme")
#t
> (absolute-path? "../filename")
#f
----

indexterm2:[+absolute-uri?+] returns true if the given uri is an absolute uri (containing 
a complete description of the named resource), or false otherwise.

[source,scheme]
----
> (absolute-uri? "ftp://example.org/resource.txt")
#t
> (absolute-uri? "resource.txt")
#f
----

indexterm2:[+glob-pattern?+] returns true if the given string contains any symbol typically 
used in a indexterm2:[glob], i.e. * ? [ ]

[source,scheme]
----
> (glob-pattern? "/home/dir/*/file.txt")
#t
> (glob-pattern? "/home/dir/x/file?.txt")
#t
> (glob-pattern? "/home/dir/x/fil[e].txt")
#t
> (glob-pattern? "/home/dir/x/file.txt")
#f
----

The following four functions generate html text for different purposes:

* indexterm2:[+html:anchor+] creates a named location given a name as a string.
* indexterm2:[+html:base+] returns a string representing the base of given uri.
* indexterm2:[+html:isindex+] creates a string for a search prompt (now deprecated for html forms).
* indexterm2:[+html:link+] takes a uri and title, and returns a link to uri displaying the title.

[source,scheme]
----
> (html:anchor "location")    ;; <1>
<A NAME="location"></A>     
> (html:base "http:peterlane.info")
<BASE HREF="http:peterlane.info">
> (html:isindex "Search term: ")
<ISINDEX PROMPT="Search term: ">
> (html:link "http://peterlane.info" "home page")
<A HREF="http://peterlane.info">home page</A>
----
<1> Use "<A HREF=#location>" to link back to this location.

indexterm2:[+make-uri+] constructs a URI given from 0 to 5 arguments.  These are: scheme, authority,
path, query, fragment.  These are optional from the front, so a single argument will be treated as the 
fragment; two arguments as a query and then a fragment, etc.

[source,scheme]
----
> (make-uri)                                                          ; <1>

> (make-uri "xyz")                                                    ; <2>
#xyz
> (make-uri "query" "xyz")                                            ; <3>
?query#xyz
> (make-uri "http" "peterlane.info" "/files/location" "query" "xyz")  ; <4>
http://peterlane.info/files/location?query#xyz
----
<1> Returns the empty string
<2> Single argument is a Fragment
<3> Query and Fragment
<4> All components: the authority in this case is the web address, and the path the relative location of files

indexterm2:[+null-directory?+] takes a string and returns true if the string
names the current directory (so changing to it would not make any change).

indexterm2:[+parse-ftp-address+] converts a string, representing an ftp address, into a list of up 
to four values: the username, password, remote site, and remote directory.  +#f+ is returned if any 
of these values is not present, or +#f+ instead of a list if the string is not an ftp address.

[source,scheme]
----
> (parse-ftp-address "ftp://username@ftp.someplace.site/")
("username" #f "ftp.someplace.site" #f)
> (parse-ftp-address "ftp://username:password@ftp.someplace.site/dir")
("username" "password" "ftp.someplace.site" "dir")
----

indexterm2:[+path->uri+] converts a given path (as a string) into a URI with an absolute address.

[source,scheme]
----
> (path->uri "filename.txt")
file:/home/NAME/CURRENT-DIRECTORY/filename.txt
> (path->uri "/usr/local/filename.txt")
file:/usr/local/filename.txt
----

indexterm2:[+uri->tree+] takes a URI and returns a list of five values corresponding to the scheme, authority, path, query, fragment:

[source,scheme]
----
> (uri->tree "file:/usr/local/filename.txt")
(file #f ("" "usr" "local" "filename.txt") #f #f)
----

indexterm2:[+uri:decode-query+] converts a given query string into an association list
of key-value pairs:

[source,scheme]
----
> (uri:decode-query "name=XXX&date=32")
((date "32") (name "XXX"))
----

indexterm2:[+uri:make-path+] takes a list of strings, and returns a path component by joining 
the strings together with a suitable separator:

[source,scheme]
----
> (uri:make-path '("a" "b" "c"))
"a/b/c"
----

indexterm2:[+uri:splitfields+] splits a string at a given character.

[source,scheme]
----
> (uri:splitfields "some text to split" #\space)
'("some" "text" "to" "split")
----

indexterm2:[+uric:decode+] and indexterm2:[+uric:encode+] convert a string to and from a form 
with certain characters rewritten using % octal values:

[source,scheme]
----
> (uric:decode "xxx%20yyy")
"xxx yyy"
> (uric:encode "xxx yyy")
"xxx%20yyy"
----

An optional second argument to +uric:encode+ provides a string of characters to allow.

