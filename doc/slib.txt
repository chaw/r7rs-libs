== SLIB Introduction and Miscellaneous Libraries

indexterm:[slib]
SLIB is a collection of packages of Scheme code, mostly written by Aubrey
Jaffer, but some collected from other sources.  Looking through the files, some
of the original dates go back to 1991, and the precedence parser into 1989.  A
number of ideas now found in Scheme and captured in the SRFIs can be traced
back to SLIB.  The repackaged files in +r7rs-libs+ have been adapted to work
with R7RS Scheme implementations: using R7RS functionality, the library system,
and operations now found in SRFIs.  

SLIB's official documentation is available at http://people.csail.mit.edu/jaffer/slib[]
and is still applicable, with some minor adjustments, to the version provided here.

There are 91 libraries within the R7RS SLIB collection.  These fall within four main 
groups of functionality:

. Textual Conversion Packages, including a parser, I/O routines, html and xml processing, 
  pretty-printing of Scheme objects, and procedures to handle times and dates.
. Mathematical Libraries, including prime numbers, some random number distributions, plotting 
  functions (to text and eps), root/limit finding libraries and a 3D modelling suite.
. Database Packages, which implement a relational database system, and a library for weighted
  trees.
. Other Packages
.. Data Structures: for enhancing arrays, working with pnm files, an object system and queues.
.. Sorting and Searching: trees, chapter-order, topological sort, along with some space filling 
   curves and sequence comparisons.
.. Other Procedures: a library of metric units for computing conversions.

The github page for +r7rs-libs+ and the wiki, https://github.com/petercrlane/r7rs-libs/wiki[],
provide additional information about SLIB and its conversion for use as R7RS libraries.  

The "examples" and "tests" directories provide (some) examples of using SLIB.  Limited 
documentation for some of the libraries follows.

This section introduces some of the smaller libraries in the SLIB collection.  The following 
chapters go into some of the libraries into more depth, especially those libraries related 
with a common theme such as array handling or time.

=== Charplot: +(import (slib charplot))+

This library provides a way to quickly visualise some data in graphical or histogram 
form from the REPL or command-line interface.  There are two basic functions: +histograph+ 
and +plot+, the latter drawing graphs of data or functions.

==== charplot:dimensions

This parameter allows you to change the size of display.  The dimensions are a two-valued 
list: the height and width in characters.  Example below.

==== histograph

indexterm2:[+histograph+] is used to plot histograms of numeric data.  Given a list or vector 
of numbers, it will arrange them into a suitable set of bins and display:

----
> (histograph '(1 1 2 3 5 5 5 7 8 9) "sample")
           ________________________________________________________________   
          |                                                                |  
          |                                                                |  
         3|-                       I                                       |  
          |                        I                                       |  
          |                        I                                       |  
       2.5|-                       I                                       |  
          |                        I                                       |  
          |                        I                                       |  
         2|-I                      I                                       |  
          | I                      I                                       |  
          | I                      I                                       |  
       1.5|-I                      I                                       |  
          | I                      I                                       |  
          | I                      I                                       |  
         1|-I     I     I          I           I     I     I               |  
          | I     I     I          I           I     I     I               |  
          | I     I     I          I           I     I     I               |  
       0.5|-I     I     I          I           I     I     I               |  
          | I     I     I          I           I     I     I               |  
          | I     I     I          I           I     I     I               |  
         0|-IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII---------------|  
          |._____:_____._____:_____._____:_____._____:_____._____:_____.___|  
  sample         2           4           6           8           10           

> (charplot:dimensions '(10 50))
> (histograph '(1 1 2 3 5 5 5 7 8 9) "sample")
           ___________________________________   
         3|-               I                  |  
          |                I                  |  
         2|-I              I                  |  
          | I              I                  |  
         1|-I   I   I      I       I   I   I  |  
          | I   I   I      I       I   I   I  |  
         0|-IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII--|  
          |_.____:____.____:____.____:____.___|  
  sample        2.5        5        7.5          
> 
----

==== plot

indexterm2:[+plot+] can be used in two ways: to display a function, or to display some data.

.Plotting a function

+plot+ will plot the values of a single argument function (taking and returning a number).
The function should be given as the first argument.  The second and third arguments specify the 
range of x values over which to plot the graph - be careful of infinite values from your 
function, which will crash +plot+.  An optional fourth argument specifies how many points 
to plot along the range of x values.

----
> (plot (lambda (x) (* x x x)) -5 5)
           _________________________________________________________________   
       140|-                              :                                 |  
          |                               :                                 |  
       120|-                              :                             *   |  
          |                               :                            *    |  
       100|-                              :                           *     |  
          |                               :                          *      |  
        80|-                              :                         *       |  
          |                               :                       **        |  
        60|-                              :                      *          |  
          |                               :                    **           |  
        40|-                              :                   *             |  
          |                               :                 ***             |  
        20|-                              :               **                |  
          |                  ***          :          *****                  |  
         0|---------------------*********************-----------------------|  
          |                **             :                                 |  
       -20|-             **               :                                 |  
          |           ***                 :                                 |  
       -40|-          *                   :                                 |  
          |         **                    :                                 |  
       -60|-       *                      :                                 |  
          |      **                       :                                 |  
       -80|-    *                         :                                 |  
          |    *                          :                                 |  
      -100|-  *                           :                                 |  
          |  *                            :                                 |  
      -120|-*                             :                                 |  
          |_._____:_____._____:_____._____:_____._____:_____._____:_____.___|  
                  -4          -2          0           2           4           

> (plot (lambda (x) (* x x x)) -5 5 30)
           _________________________________________________________________   
       140|-                              :                                 |  
          |                               :                                 |  
       120|-                              :                             *   |  
          |                               :                                 |  
       100|-                              :                           *     |  
          |                               :                                 |  
        80|-                              :                         *       |  
          |                               :                                 |  
        60|-                              :                       *         |  
          |                               :                     *           |  
        40|-                              :                   *             |  
          |                               :                 *               |  
        20|-                              :               *                 |  
          |                    *          :          * *                    |  
         0|----------------------*-*-*-*-*:*-*-*-*-*------------------------|  
          |                  *            :                                 |  
       -20|-              *               :                                 |  
          |             *                 :                                 |  
       -40|-          *                   :                                 |  
          |         *                     :                                 |  
       -60|-      *                       :                                 |  
          |                               :                                 |  
       -80|-    *                         :                                 |  
          |                               :                                 |  
      -100|-  *                           :                                 |  
          |                               :                                 |  
      -120|-*                             :                                 |  
          |_._____:_____._____:_____._____:_____._____:_____._____:_____.___|  
                  -4          -2          0           2           4          
----

.Plotting some data

This second form of +plot+ directly plots a list or vector of pairs of (x, y)
coordinates. Second and third arguments give labels to the two axes.

----
> (define data (map (lambda (x) (list x (* x x x))) (iota 11 -5)))
> data
((-5 -125) (-4 -64) (-3 -27) (-2 -8) (-1 -1) (0 0) (1 1) (2 8) (3 27) (4 64) (5 125))
> (plot data "x-values" "y-values")
 y-values  _________________________________________________________________   
       140|-                              :                                 |  
          |                               :                                 |  
       120|-                              :                             *   |  
          |                               :                                 |  
       100|-                              :                                 |  
          |                               :                                 |  
        80|-                              :                                 |  
          |                               :                                 |  
        60|-                              :                       *         |  
          |                               :                                 |  
        40|-                              :                                 |  
          |                               :                 *               |  
        20|-                              :                                 |  
          |                   *           :           *                     |  
         0|-------------------------*-----*-----*---------------------------|  
          |                               :                                 |  
       -20|-                              :                                 |  
          |             *                 :                                 |  
       -40|-                              :                                 |  
          |                               :                                 |  
       -60|-      *                       :                                 |  
          |                               :                                 |  
       -80|-                              :                                 |  
          |                               :                                 |  
      -100|-                              :                                 |  
          |                               :                                 |  
      -120|-*                             :                                 |  
          |_._____:_____._____:_____._____:_____._____:_____._____:_____.___|  
 x-values         -4          -2          0           2           4            

----

=== Database

indexterm:[database] indexterm:[relational database]
SLIB includes a relational database system, written entirely in Scheme.  This is a complex 
and inter-related set of libraries.  The following example (from "slib-examples/db-1.sps") 
provides an introduction to creating, opening and using a simple database.  

.Note
****
The database system stores information in files.  It also sets up locks on those 
files to prevent multiple users trying to change the same data.  The code has been 
tested under Linux, but requires further tests and possible modification on other 
operating systems.

If your application fails with any errors, it is possible the lock files will remain 
and must be deleted before you can access the database again: the lock files start 
".$" and ".#", and are thus hidden on Linux and similar systems.
****

More information on SLIB's database system is available at: http://people.csail.mit.edu/jaffer/slib/Using-Databases.html[].
After understanding the example below, work through section 6.1.2 on Table Operations.  

==== Creating a database

A database can be created using one or more "backends".  Currently, only an association list 
backend is supported, as provided by +(slib alist-table)+.  A database is created to a given filename:

[source,scheme]
----
(import (scheme base)
        (slib databases)
        (slib alist-table))

(define db (create-database "mydb" 'alist-table))
----

The above code imports the necessary libraries, and creates a database in the file "mydb" using 
an association-list backend.  A reference to this database is stored in +db+.

Next, the database can be opened:

[source,scheme]
----
(define rdb (open-database! db))
----

As we will see below, a database can be opened using either the database reference from the +create-database+ 
command, or from the filename.  So +(open-database! "mydb")+ works just as well.

Databases can be opened in _mutable_ or _immutable_ modes: opened to be changed, or just for reading.  
The exclamation mark ! indicates that the database is mutable.  

Data in a database is stored within _tables_.  Before we can use our new database, we need to create 
at least one table.  A table is defined from three elements:

. its _name_
. its _primary key field(s)_
. its _other fields_

In our example, we make an example with name "testit", a single primary key "id", and two fields "first" and "second".
Each field is defined with an associated type (allowed types are described in the
http://people.csail.mit.edu/jaffer/slib/Catalog-Representation.html#Catalog-Representation[online] documentation).  
In this case, our "id" field will be a number, and the two other fields strings.

The basic definition is: 

----
(testit                                  ; the table name
  ((id number))                          ; list of primary key field (name type) pairs
  ((first string) (second string)))      ; list of other field (name type) pairs
----

When defining a table, we can also provide a list of data to add.  The data are simply given in rows, with values for all fields:

----
((1 "Peter" "Lane")   ; row 1: (id first second)
 (2 "Joe" "Smith"))   ; row 2: (id first second)
----

Putting the definitions together, the following line of code creates the +testit+ table, and adds some initial data:

[source,scheme]
----
(define-tables rdb '(testit ((id number)) ((first string) (second string))
                            ((1 "Peter" "Lane")
                             (2 "Joe" "Smith"))))
----

Finally, don't forget to close the database, which ensures everything is saved on disk:

[source,scheme]
----
(close-database rdb)
----

You can examine the file "mydb" to read the definition and data.

==== Working with a database

Databases should only need constructing once.  Afterwards, you will open and work with the 
existing file.  To open an existing database, you need to know its filename:

[source,scheme]
----
(define mydb (open-database! "mydb"))   ; open a mutable database
----

To access information in a table, you need to extract the table of interest:

[source,scheme]
----
(define table (open-table! mydb 'testit))
----

If you were to examine +table+, you would find it is a _procedure_.  The table 
procedure takes an operation definition as its argument, and returns a new procedure 
to perform that operation on some data.

For example, if we wish to retrieve a row of data.  The operation definition is +'row:retrieve+.
The returned procedure then takes the primary key(s) to locate in the database:

[source,scheme]
----
((table 'row:retrieve) 1)   ; returns the row with id 1: (1 "Peter" "Lane")
----

Try displaying all rows (note, the third case will return +#f+):

[source,scheme]
----
(display "Retrieving 1: ") (display ((table 'row:retrieve) 1)) (newline)
(display "Retrieving 2: ") (display ((table 'row:retrieve) 2)) (newline)
(display "Retrieving 3: ") (display ((table 'row:retrieve) 3)) (newline)
----

A new row can be inserted in a similar way:

[source,scheme]
----
((table 'row:insert) '(3 "Jane" "Wheeler"))
----

Further row operations exist to update and delete.

Operations are also available to work on multiple rows.  A useful case is +for-each-row+:

[source,scheme]
----
((table 'for-each-row) (lambda (row) (display "Row: ") (display row) (newline)))
----

Finally, don't forget to close the database, which ensures everything is saved on disk:

[source,scheme]
----
(close-database mydb)
----

include::slib-dynamic.txt[]

include::slib-format.txt[]

include::slib-soundex.txt[]

include::slib-xml-parse.txt[]

=== URIs: +(import (slib uri))+

A package for creating, decoding and testing various forms of URI.

==== absolute-path

indexterm2:[+absolute-path?+] returns true if the given filename is an absolute
path, or false if it depends on the current directory.

[source,scheme]
----
> (absolute-path? "/usr/local/bin/scheme")
#t
> (absolute-path? "../filename")
#f
----

==== absolute-uri?

indexterm2:[+absolute-uri?+] returns true if the given uri is an absolute uri (containing 
a complete description of the named resource), or false otherwise.

[source,scheme]
----
> (absolute-uri? "ftp://example.org/resource.txt")
#t
> (absolute-uri? "resource.txt")
#f
----

==== glob-pattern?

indexterm2:[+glob-pattern?+] returns true if the given string contains any symbol typically 
used in a indexterm2:[glob], i.e. * ? [ ]

[source,scheme]
----
> (glob-pattern? "/home/dir/*/file.txt")
#t
> (glob-pattern? "/home/dir/x/file?.txt")
#t
> (glob-pattern? "/home/dir/x/fil[e].txt")
#t
> (glob-pattern? "/home/dir/x/file.txt")
#f
----

==== html syntax

The following four functions generate html text for different purposes:

* indexterm2:[+html:anchor+] creates a named location given a name as a string.
* indexterm2:[+html:base+] returns a string representing the base of given uri.
* indexterm2:[+html:isindex+] creates a string for a search prompt (now deprecated for html forms).
* indexterm2:[+html:link+] takes a uri and title, and returns a link to uri displaying the title.

[source,scheme]
----
> (html:anchor "location")    ;; <1>
<A NAME="location"></A>     
> (html:base "http:peterlane.info")
<BASE HREF="http:peterlane.info">
> (html:isindex "Search term: ")
<ISINDEX PROMPT="Search term: ">
> (html:link "http://peterlane.info" "home page")
<A HREF="http://peterlane.info">home page</A>
----
<1> Use "<A HREF=#location>" to link back to this location.

==== make-uri

indexterm2:[+make-uri+] constructs a URI given from 0 to 5 arguments.  These are: scheme, authority,
path, query, fragment.  These are optional from the front, so a single argument will be treated as the 
fragment; two arguments as a query and then a fragment, etc.

[source,scheme]
----
> (make-uri)                                                          ; <1>

> (make-uri "xyz")                                                    ; <2>
#xyz
> (make-uri "query" "xyz")                                            ; <3>
?query#xyz
> (make-uri "http" "peterlane.info" "/files/location" "query" "xyz")  ; <4>
http://peterlane.info/files/location?query#xyz
----
<1> Returns the empty string
<2> Single argument is a Fragment
<3> Query and Fragment
<4> All components: the authority in this case is the web address, and the path the relative location of files

==== null-directory?

indexterm2:[+null-directory?+] takes a string and returns true if the string
names the current directory (so changing to it would not make any change).

==== parse-ftp-address

indexterm2:[+parse-ftp-address+] converts a string, representing an ftp address, into a list of up 
to four values: the username, password, remote site, and remote directory.  +#f+ is returned if any 
of these values is not present, or +#f+ instead of a list if the string is not an ftp address.

[source,scheme]
----
> (parse-ftp-address "ftp://username@ftp.someplace.site/")
("username" #f "ftp.someplace.site" #f)
> (parse-ftp-address "ftp://username:password@ftp.someplace.site/dir")
("username" "password" "ftp.someplace.site" "dir")
----

==== path->uri

indexterm2:[+path->uri+] converts a given path (as a string) into a URI with an absolute address.

[source,scheme]
----
> (path->uri "filename.txt")
file:/home/NAME/CURRENT-DIRECTORY/filename.txt
> (path->uri "/usr/local/filename.txt")
file:/usr/local/filename.txt
----

==== uri->tree

indexterm2:[+uri->tree+] takes a URI and returns a list of five values corresponding to the scheme, authority, path, query, fragment:

[source,scheme]
----
> (uri->tree "file:/usr/local/filename.txt")
(file #f ("" "usr" "local" "filename.txt") #f #f)
----

==== uri:decode-query

indexterm2:[+uri:decode-query+] converts a given query string into an association list
of key-value pairs:

[source,scheme]
----
> (uri:decode-query "name=XXX&date=32")
((date "32") (name "XXX"))
----

==== uri:make-path

indexterm2:[+uri:make-path+] takes a list of strings, and returns a path component by joining 
the strings together with a suitable separator:

[source,scheme]
----
> (uri:make-path '("a" "b" "c"))
"a/b/c"
----

==== uri:splitfields

indexterm2:[+uri:splitfields+] splits a string at a given character.

[source,scheme]
----
> (uri:splitfields "some text to split" #\space)
'("some" "text" "to" "split")
----

==== uric:decode/encode

indexterm2:[+uric:decode+] and indexterm2:[+uric:encode+] convert a string to and from a form 
with certain characters rewritten using % octal values:

[source,scheme]
----
> (uric:decode "xxx%20yyy")
"xxx yyy"
> (uric:encode "xxx yyy")
"xxx%20yyy"
----

An optional second argument to +uric:encode+ provides a string of characters to allow.

